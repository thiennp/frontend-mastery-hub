<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 11 Assessment - State Management & Effects</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .assessment-content {
            padding: 40px;
        }

        .progress-bar {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .question {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px solid #f0f0f0;
            border-radius: 12px;
            background: #fafafa;
            transition: all 0.3s ease;
        }

        .question:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
        }

        .question-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            font-size: 0.9rem;
        }

        .question h3 {
            display: inline-block;
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .question p {
            margin-bottom: 20px;
            color: #666;
            font-size: 1rem;
        }

        .options {
            list-style: none;
        }

        .option {
            margin-bottom: 12px;
            padding: 15px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option.correct {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .option.incorrect {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .option input[type="radio"] {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            flex: 1;
            font-weight: 500;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 15px 0;
            overflow-x: auto;
            border: 1px solid #333;
        }

        .code-block .keyword { color: #569cd6; }
        .code-block .string { color: #ce9178; }
        .code-block .comment { color: #6a9955; }
        .code-block .function { color: #dcdcaa; }

        .submit-section {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .score {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .score.excellent { color: #10b981; }
        .score.good { color: #f59e0b; }
        .score.needs-improvement { color: #ef4444; }

        .feedback {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #666;
        }

        .retake-btn {
            background: #6b7280;
            margin-left: 15px;
        }

        .explanation {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .explanation h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .timer {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .assessment-content {
                padding: 20px;
            }
            
            .question {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="timer" id="timer">Time: 30:00</div>
    
    <div class="container">
        <div class="header">
            <h1>Level 11 Assessment</h1>
            <p>State Management & Effects - Advanced React Patterns</p>
        </div>

        <div class="assessment-content">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="warning">
                <strong>⚠️ Assessment Rules:</strong>
                <ul style="margin: 10px 0 0 20px;">
                    <li>You have 30 minutes to complete this assessment</li>
                    <li>Answer all questions to get your score</li>
                    <li>You can change your answers before submitting</li>
                    <li>This assessment covers state management patterns, useEffect hooks, Context API, and custom hooks</li>
                </ul>
            </div>

            <form id="assessmentForm">
                <!-- Question 1 -->
                <div class="question" data-question="1">
                    <h3><span class="question-number">1</span>State Management Patterns</h3>
                    <p>Which state management pattern is most appropriate for managing complex application state that needs to be shared across multiple components?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q1" value="a" id="q1a">
                            <label for="q1a">Local component state with useState</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q1" value="b" id="q1b">
                            <label for="q1b">Context API with useReducer</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q1" value="c" id="q1c">
                            <label for="q1c">Props drilling with multiple useState calls</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q1" value="d" id="q1d">
                            <label for="q1d">Global variables declared outside components</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 2 -->
                <div class="question" data-question="2">
                    <h3><span class="question-number">2</span>useEffect Hook Dependencies</h3>
                    <p>What will happen when this useEffect runs?</p>
                    <div class="code-block">
<span class="keyword">const</span> [count, setCount] = <span class="function">useState</span>(<span class="string">0</span>);
<span class="keyword">const</span> [name, setName] = <span class="function">useState</span>(<span class="string">''</span>);

<span class="function">useEffect</span>(() => {
  <span class="function">console.log</span>(<span class="string">'Effect ran'</span>);
}, [count]);
                    </div>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q2" value="a" id="q2a">
                            <label for="q2a">Runs on every render</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q2" value="b" id="q2b">
                            <label for="q2b">Runs only when count changes</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q2" value="c" id="q2c">
                            <label for="q2c">Runs only when name changes</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q2" value="d" id="q2d">
                            <label for="q2d">Runs only on component mount</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 3 -->
                <div class="question" data-question="3">
                    <h3><span class="question-number">3</span>Context API Performance</h3>
                    <p>How can you prevent unnecessary re-renders when using Context API with frequently changing values?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q3" value="a" id="q3a">
                            <label for="q3a">Split contexts by concern and use multiple providers</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q3" value="b" id="q3b">
                            <label for="q3b">Use a single context for all state</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q3" value="c" id="q3c">
                            <label for="q3c">Always use useMemo for context values</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q3" value="d" id="q3d">
                            <label for="q3d">Pass functions directly in context value</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 4 -->
                <div class="question" data-question="4">
                    <h3><span class="question-number">4</span>Custom Hooks</h3>
                    <p>What is the main benefit of creating custom hooks in React?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q4" value="a" id="q4a">
                            <label for="q4a">They make components render faster</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q4" value="b" id="q4b">
                            <label for="q4b">They allow sharing stateful logic between components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q4" value="c" id="q4c">
                            <label for="q4c">They reduce bundle size</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q4" value="d" id="q4d">
                            <label for="q4d">They eliminate the need for useEffect</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 5 -->
                <div class="question" data-question="5">
                    <h3><span class="question-number">5</span>useReducer vs useState</h3>
                    <p>When should you use useReducer instead of useState?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q5" value="a" id="q5a">
                            <label for="q5a">When you have a single state value</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q5" value="b" id="q5b">
                            <label for="q5b">When state logic is complex and involves multiple sub-values</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q5" value="c" id="q5c">
                            <label for="q5c">When you want to avoid re-renders</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q5" value="d" id="q5d">
                            <label for="q5d">When you need to store functions in state</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 6 -->
                <div class="question" data-question="6">
                    <h3><span class="question-number">6</span>Effect Cleanup</h3>
                    <p>What is the purpose of the cleanup function in useEffect?</p>
                    <div class="code-block">
<span class="function">useEffect</span>(() => {
  <span class="keyword">const</span> timer = <span class="function">setInterval</span>(() => {
    <span class="function">console.log</span>(<span class="string">'Timer tick'</span>);
  }, <span class="string">1000</span>);

  <span class="keyword">return</span> () => {
    <span class="function">clearInterval</span>(timer);
  };
}, []);
                    </div>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q6" value="a" id="q6a">
                            <label for="q6a">To optimize performance by memoizing values</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q6" value="b" id="q6b">
                            <label for="q6b">To prevent memory leaks and clean up side effects</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q6" value="c" id="q6c">
                            <label for="q6c">To trigger re-renders when dependencies change</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q6" value="d" id="q6d">
                            <label for="q6d">To update the component's state</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 7 -->
                <div class="question" data-question="7">
                    <h3><span class="question-number">7</span>State Updates</h3>
                    <p>What is the correct way to update state based on previous state?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q7" value="a" id="q7a">
                            <label for="q7a">setCount(count + 1)</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q7" value="b" id="q7b">
                            <label for="q7b">setCount(prevCount => prevCount + 1)</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q7" value="c" id="q7c">
                            <label for="q7c">count = count + 1</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q7" value="d" id="q7d">
                            <label for="q7d">useState(count + 1)</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 8 -->
                <div class="question" data-question="8">
                    <h3><span class="question-number">8</span>Context Provider Pattern</h3>
                    <p>How should you structure a Context Provider to avoid unnecessary re-renders?</p>
                    <div class="code-block">
<span class="comment">// Which approach is better?</span>
<span class="keyword">const</span> AppContext = <span class="function">createContext</span>();

<span class="comment">// Option A</span>
<span class="keyword">const</span> AppProvider = ({ children }) => {
  <span class="keyword">const</span> [user, setUser] = <span class="function">useState</span>(<span class="string">null</span>);
  <span class="keyword">const</span> [theme, setTheme] = <span class="function">useState</span>(<span class="string">'light'</span>);
  <span class="keyword">const</span> [loading, setLoading] = <span class="function">useState</span>(<span class="string">false</span>);
  
  <span class="keyword">return</span> (
    &lt;AppContext.Provider value={{ user, setUser, theme, setTheme, loading, setLoading }}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
};
                    </div>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q8" value="a" id="q8a">
                            <label for="q8a">This approach is optimal for all scenarios</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q8" value="b" id="q8b">
                            <label for="q8b">Split into separate contexts for user, theme, and loading</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q8" value="c" id="q8c">
                            <label for="q8c">Use useMemo to memoize the context value</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q8" value="d" id="q8d">
                            <label for="q8d">Both B and C are correct approaches</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 9 -->
                <div class="question" data-question="9">
                    <h3><span class="question-number">9</span>Effect Dependencies</h3>
                    <p>What will happen if you omit a dependency from the useEffect dependency array?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q9" value="a" id="q9a">
                            <label for="q9a">The effect will run only once on mount</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q9" value="b" id="q9b">
                            <label for="q9b">The effect will have stale closure over the omitted dependency</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q9" value="c" id="q9c">
                            <label for="q9c">The effect will run on every render</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q9" value="d" id="q9d">
                            <label for="q9d">The component will throw an error</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 10 -->
                <div class="question" data-question="10">
                    <h3><span class="question-number">10</span>State Management Best Practices</h3>
                    <p>Which approach is considered a best practice for managing form state in React?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q10" value="a" id="q10a">
                            <label for="q10a">Using a separate useState for each form field</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q10" value="b" id="q10b">
                            <label for="q10b">Using useReducer with a single state object for all form fields</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q10" value="c" id="q10c">
                            <label for="q10c">Storing form state in a global context</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q10" value="d" id="q10d">
                            <label for="q10d">Using refs to directly manipulate DOM elements</label>
                        </li>
                    </ul>
                </div>

                <div class="submit-section">
                    <button type="submit" class="btn" id="submitBtn">Submit Assessment</button>
                </div>
            </form>

            <div class="results" id="results">
                <div class="score" id="score">0/10</div>
                <div class="feedback" id="feedback"></div>
                <button class="btn" onclick="location.reload()">Retake Assessment</button>
            </div>
        </div>
    </div>

    <script>
        // Assessment data
        const questions = [
            {
                question: 1,
                correct: 'b',
                explanation: 'Context API with useReducer is ideal for complex shared state. It provides a centralized way to manage state and actions while avoiding prop drilling.'
            },
            {
                question: 2,
                correct: 'b',
                explanation: 'The effect runs only when the count dependency changes. The name state is not in the dependency array, so changes to name won\'t trigger the effect.'
            },
            {
                question: 3,
                correct: 'd',
                explanation: 'Both splitting contexts by concern and using useMemo for context values are correct approaches. Splitting contexts prevents unnecessary re-renders when unrelated state changes.'
            },
            {
                question: 4,
                correct: 'b',
                explanation: 'Custom hooks allow you to extract component logic into reusable functions. This enables sharing stateful logic between components without changing the component hierarchy.'
            },
            {
                question: 5,
                correct: 'b',
                explanation: 'useReducer is better when state logic is complex and involves multiple sub-values. It provides a more predictable way to update state through actions.'
            },
            {
                question: 6,
                correct: 'b',
                explanation: 'The cleanup function prevents memory leaks by cleaning up side effects like timers, subscriptions, or event listeners when the component unmounts or dependencies change.'
            },
            {
                question: 7,
                correct: 'b',
                explanation: 'Using a function with the previous state ensures you\'re working with the most current state value, especially important when multiple state updates might be batched.'
            },
            {
                question: 8,
                correct: 'd',
                explanation: 'Both splitting contexts and using useMemo are valid approaches. The choice depends on your specific use case and performance requirements.'
            },
            {
                question: 9,
                correct: 'b',
                explanation: 'Omitting dependencies can lead to stale closures where the effect captures old values of variables. This is a common source of bugs in React applications.'
            },
            {
                question: 10,
                correct: 'b',
                explanation: 'useReducer with a single state object is often the best approach for complex forms as it provides better organization and predictable state updates.'
            }
        ];

        // Timer functionality
        let timeLeft = 30 * 60; // 30 minutes in seconds
        const timerElement = document.getElementById('timer');
        const timer = setInterval(() => {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerElement.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            if (timeLeft <= 0) {
                clearInterval(timer);
                submitAssessment();
            }
            
            timeLeft--;
        }, 1000);

        // Progress tracking
        function updateProgress() {
            const totalQuestions = questions.length;
            const answeredQuestions = document.querySelectorAll('input[type="radio"]:checked').length;
            const progress = (answeredQuestions / totalQuestions) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        // Add event listeners for progress tracking
        document.querySelectorAll('input[type="radio"]').forEach(input => {
            input.addEventListener('change', updateProgress);
        });

        // Submit assessment
        function submitAssessment() {
            clearInterval(timer);
            
            let score = 0;
            const results = [];
            
            questions.forEach(q => {
                const selected = document.querySelector(`input[name="q${q.question}"]:checked`);
                const isCorrect = selected && selected.value === q.correct;
                
                if (isCorrect) score++;
                
                results.push({
                    question: q.question,
                    correct: q.correct,
                    selected: selected ? selected.value : null,
                    isCorrect: isCorrect,
                    explanation: q.explanation
                });
            });

            // Show results
            document.getElementById('assessmentForm').style.display = 'none';
            document.getElementById('results').style.display = 'block';
            
            const scoreElement = document.getElementById('score');
            const feedbackElement = document.getElementById('feedback');
            
            scoreElement.textContent = `${score}/${questions.length}`;
            
            // Add score styling
            scoreElement.className = 'score';
            if (score >= 8) {
                scoreElement.classList.add('excellent');
                feedbackElement.textContent = 'Excellent! You have a strong understanding of state management and effects in React.';
            } else if (score >= 6) {
                scoreElement.classList.add('good');
                feedbackElement.textContent = 'Good job! You understand the basics but could benefit from more practice with advanced patterns.';
            } else {
                scoreElement.classList.add('needs-improvement');
                feedbackElement.textContent = 'Keep studying! Focus on understanding state management patterns, useEffect hooks, and Context API.';
            }

            // Show explanations for incorrect answers
            results.forEach(result => {
                if (!result.isCorrect) {
                    const questionElement = document.querySelector(`[data-question="${result.question}"]`);
                    const explanationDiv = document.createElement('div');
                    explanationDiv.className = 'explanation';
                    explanationDiv.innerHTML = `
                        <h4>Question ${result.question} Explanation:</h4>
                        <p>${result.explanation}</p>
                    `;
                    questionElement.appendChild(explanationDiv);
                }
            });
        }

        // Form submission
        document.getElementById('assessmentForm').addEventListener('submit', (e) => {
            e.preventDefault();
            submitAssessment();
        });

        // Initialize progress
        updateProgress();
    </script>
</body>
</html>
