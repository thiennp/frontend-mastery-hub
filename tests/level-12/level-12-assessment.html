<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 12 Assessment - Advanced React Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .assessment-content {
            padding: 40px;
        }

        .progress-bar {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .question {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px solid #f0f0f0;
            border-radius: 12px;
            background: #fafafa;
            transition: all 0.3s ease;
        }

        .question:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
        }

        .question-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            font-size: 0.9rem;
        }

        .question h3 {
            display: inline-block;
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .question p {
            margin-bottom: 20px;
            color: #666;
            font-size: 1rem;
        }

        .options {
            list-style: none;
        }

        .option {
            margin-bottom: 12px;
            padding: 15px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option.correct {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .option.incorrect {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .option input[type="radio"] {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .option label {
            cursor: pointer;
            flex: 1;
            font-weight: 500;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 15px 0;
            overflow-x: auto;
            border: 1px solid #333;
        }

        .code-block .keyword { color: #569cd6; }
        .code-block .string { color: #ce9178; }
        .code-block .comment { color: #6a9955; }
        .code-block .function { color: #dcdcaa; }

        .submit-section {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .score {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .score.excellent { color: #10b981; }
        .score.good { color: #f59e0b; }
        .score.needs-improvement { color: #ef4444; }

        .feedback {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #666;
        }

        .retake-btn {
            background: #6b7280;
            margin-left: 15px;
        }

        .explanation {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .explanation h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .timer {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .assessment-content {
                padding: 20px;
            }
            
            .question {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="timer" id="timer">Time: 30:00</div>
    
    <div class="container">
        <div class="header">
            <h1>Level 12 Assessment</h1>
            <p>Advanced React Patterns - HOCs, Render Props, Compound Components, Custom Hooks</p>
        </div>

        <div class="assessment-content">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="warning">
                <strong>⚠️ Assessment Rules:</strong>
                <ul style="margin: 10px 0 0 20px;">
                    <li>You have 30 minutes to complete this assessment</li>
                    <li>Answer all questions to get your score</li>
                    <li>You can change your answers before submitting</li>
                    <li>This assessment covers HOCs, Render Props, Compound Components, Custom Hooks, and Performance Optimization</li>
                </ul>
            </div>

            <form id="assessmentForm">
                <!-- Question 1 -->
                <div class="question" data-question="1">
                    <h3><span class="question-number">1</span>Higher-Order Components</h3>
                    <p>What is the primary purpose of Higher-Order Components (HOCs) in React?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q1" value="a" id="q1a">
                            <label for="q1a">To replace class components with function components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q1" value="b" id="q1b">
                            <label for="q1b">To share logic between components without changing their structure</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q1" value="c" id="q1c">
                            <label for="q1c">To improve component performance by reducing re-renders</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q1" value="d" id="q1d">
                            <label for="q1d">To create components that can only be used once</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 2 -->
                <div class="question" data-question="2">
                    <h3><span class="question-number">2</span>Render Props Pattern</h3>
                    <p>Which of the following best describes the Render Props pattern?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q2" value="a" id="q2a">
                            <label for="q2a">A pattern where components receive render functions as props</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q2" value="b" id="q2b">
                            <label for="q2b">A pattern for creating reusable UI components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q2" value="c" id="q2c">
                            <label for="q2c">A pattern for managing component state</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q2" value="d" id="q2d">
                            <label for="q2d">A pattern for optimizing component performance</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 3 -->
                <div class="question" data-question="3">
                    <h3><span class="question-number">3</span>Compound Components</h3>
                    <p>What is the main advantage of using Compound Components?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q3" value="a" id="q3a">
                            <label for="q3a">They improve component performance</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q3" value="b" id="q3b">
                            <label for="q3b">They provide a flexible and intuitive API for complex UI components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q3" value="c" id="q3c">
                            <label for="q3c">They reduce bundle size</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q3" value="d" id="q3d">
                            <label for="q3d">They eliminate the need for props</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 4 -->
                <div class="question" data-question="4">
                    <h3><span class="question-number">4</span>Custom Hooks</h3>
                    <p>What is the main benefit of creating custom hooks in React?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q4" value="a" id="q4a">
                            <label for="q4a">They make components render faster</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q4" value="b" id="q4b">
                            <label for="q4b">They allow sharing stateful logic between components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q4" value="c" id="q4c">
                            <label for="q4c">They reduce bundle size</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q4" value="d" id="q4d">
                            <label for="q4d">They eliminate the need for useEffect</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 5 -->
                <div class="question" data-question="5">
                    <h3><span class="question-number">5</span>Performance Optimization</h3>
                    <p>When should you use React.memo?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q5" value="a" id="q5a">
                            <label for="q5a">For all components to improve performance</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q5" value="b" id="q5b">
                            <label for="q5b">For components that receive the same props frequently</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q5" value="c" id="q5c">
                            <label for="q5c">Only for class components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q5" value="d" id="q5d">
                            <label for="q5d">Never, as it causes more problems than it solves</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 6 -->
                <div class="question" data-question="6">
                    <h3><span class="question-number">6</span>useMemo and useCallback</h3>
                    <p>What is the difference between useMemo and useCallback?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q6" value="a" id="q6a">
                            <label for="q6a">useMemo memoizes values, useCallback memoizes functions</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q6" value="b" id="q6b">
                            <label for="q6b">useMemo is for class components, useCallback is for function components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q6" value="c" id="q6c">
                            <label for="q6c">There is no difference, they are the same</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q6" value="d" id="q6d">
                            <label for="q6d">useMemo is deprecated, use useCallback instead</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 7 -->
                <div class="question" data-question="7">
                    <h3><span class="question-number">7</span>Error Boundaries</h3>
                    <p>What types of errors can Error Boundaries catch?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q7" value="a" id="q7a">
                            <label for="q7a">All JavaScript errors in the component tree</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q7" value="b" id="q7b">
                            <label for="q7b">Only errors in render methods and lifecycle methods</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q7" value="c" id="q7c">
                            <label for="q7c">Only errors in event handlers</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q7" value="d" id="q7d">
                            <label for="q7d">Only errors in async operations</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 8 -->
                <div class="question" data-question="8">
                    <h3><span class="question-number">8</span>HOC Composition</h3>
                    <p>How can you compose multiple HOCs together?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q8" value="a" id="q8a">
                            <label for="q8a">By nesting them: withA(withB(withC(Component)))</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q8" value="b" id="q8b">
                            <label for="q8b">By using an array: [withA, withB, withC](Component)</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q8" value="c" id="q8c">
                            <label for="q8c">By using the compose utility: compose(withA, withB, withC)(Component)</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q8" value="d" id="q8d">
                            <label for="q8d">Both A and C are correct approaches</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 9 -->
                <div class="question" data-question="9">
                    <h3><span class="question-number">9</span>Render Props vs HOCs</h3>
                    <p>What is a key advantage of Render Props over HOCs?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q9" value="a" id="q9a">
                            <label for="q9a">Better performance</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q9" value="b" id="q9b">
                            <label for="q9b">Avoids the wrapper hell problem</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q9" value="c" id="q9c">
                            <label for="q9c">Smaller bundle size</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q9" value="d" id="q9d">
                            <label for="q9d">Easier to test</label>
                        </li>
                    </ul>
                </div>

                <!-- Question 10 -->
                <div class="question" data-question="10">
                    <h3><span class="question-number">10</span>Performance Best Practices</h3>
                    <p>Which of the following is NOT a good performance optimization practice?</p>
                    <ul class="options">
                        <li class="option">
                            <input type="radio" name="q10" value="a" id="q10a">
                            <label for="q10a">Using React.memo for all components</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q10" value="b" id="q10b">
                            <label for="q10b">Using useMemo for expensive calculations</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q10" value="c" id="q10c">
                            <label for="q10c">Using useCallback for event handlers passed as props</label>
                        </li>
                        <li class="option">
                            <input type="radio" name="q10" value="d" id="q10d">
                            <label for="q10d">Using code splitting for large components</label>
                        </li>
                    </ul>
                </div>

                <div class="submit-section">
                    <button type="submit" class="btn" id="submitBtn">Submit Assessment</button>
                </div>
            </form>

            <div class="results" id="results">
                <div class="score" id="score">0/10</div>
                <div class="feedback" id="feedback"></div>
                <button class="btn" onclick="location.reload()">Retake Assessment</button>
            </div>
        </div>
    </div>

    <script>
        // Assessment data
        const questions = [
            {
                question: 1,
                correct: 'b',
                explanation: 'HOCs are functions that take a component and return a new component with additional functionality, allowing you to share logic between components without changing their structure.'
            },
            {
                question: 2,
                correct: 'a',
                explanation: 'Render Props is a pattern where a component accepts a function as a prop and calls it to determine what to render, providing a way to share code between components.'
            },
            {
                question: 3,
                correct: 'b',
                explanation: 'Compound Components provide a flexible and intuitive API for complex UI components by allowing multiple components to work together to form a cohesive interface.'
            },
            {
                question: 4,
                correct: 'b',
                explanation: 'Custom hooks allow you to extract component logic into reusable functions, enabling sharing of stateful logic between components without changing the component hierarchy.'
            },
            {
                question: 5,
                correct: 'b',
                explanation: 'React.memo should be used for components that receive the same props frequently, as it prevents unnecessary re-renders by doing a shallow comparison of props.'
            },
            {
                question: 6,
                correct: 'a',
                explanation: 'useMemo memoizes the result of a computation (values), while useCallback memoizes the function itself. Both help prevent unnecessary recalculations and re-renders.'
            },
            {
                question: 7,
                correct: 'b',
                explanation: 'Error Boundaries can only catch errors in render methods, lifecycle methods, and constructors of the whole tree below them. They cannot catch errors in event handlers, async code, or during server-side rendering.'
            },
            {
                question: 8,
                correct: 'd',
                explanation: 'Both nesting HOCs (withA(withB(withC(Component)))) and using compose utility (compose(withA, withB, withC)(Component)) are correct approaches for composing multiple HOCs.'
            },
            {
                question: 9,
                correct: 'b',
                explanation: 'Render Props avoid the wrapper hell problem that can occur with HOCs, where multiple HOCs can create deeply nested component hierarchies that are hard to debug and understand.'
            },
            {
                question: 10,
                correct: 'a',
                explanation: 'Using React.memo for all components is not a good practice. React.memo should only be used when you have identified a performance problem and the component receives the same props frequently.'
            }
        ];

        // Timer functionality
        let timeLeft = 30 * 60; // 30 minutes in seconds
        const timerElement = document.getElementById('timer');
        const timer = setInterval(() => {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerElement.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            if (timeLeft <= 0) {
                clearInterval(timer);
                submitAssessment();
            }
            
            timeLeft--;
        }, 1000);

        // Progress tracking
        function updateProgress() {
            const totalQuestions = questions.length;
            const answeredQuestions = document.querySelectorAll('input[type="radio"]:checked').length;
            const progress = (answeredQuestions / totalQuestions) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        // Add event listeners for progress tracking
        document.querySelectorAll('input[type="radio"]').forEach(input => {
            input.addEventListener('change', updateProgress);
        });

        // Submit assessment
        function submitAssessment() {
            clearInterval(timer);
            
            let score = 0;
            const results = [];
            
            questions.forEach(q => {
                const selected = document.querySelector(`input[name="q${q.question}"]:checked`);
                const isCorrect = selected && selected.value === q.correct;
                
                if (isCorrect) score++;
                
                results.push({
                    question: q.question,
                    correct: q.correct,
                    selected: selected ? selected.value : null,
                    isCorrect: isCorrect,
                    explanation: q.explanation
                });
            });

            // Show results
            document.getElementById('assessmentForm').style.display = 'none';
            document.getElementById('results').style.display = 'block';
            
            const scoreElement = document.getElementById('score');
            const feedbackElement = document.getElementById('feedback');
            
            scoreElement.textContent = `${score}/${questions.length}`;
            
            // Add score styling
            scoreElement.className = 'score';
            if (score >= 8) {
                scoreElement.classList.add('excellent');
                feedbackElement.textContent = 'Excellent! You have a strong understanding of advanced React patterns. You\'re ready to build complex, scalable React applications.';
            } else if (score >= 6) {
                scoreElement.classList.add('good');
                feedbackElement.textContent = 'Good job! You understand the basics of advanced React patterns but could benefit from more practice with HOCs, Render Props, and performance optimization.';
            } else {
                scoreElement.classList.add('needs-improvement');
                feedbackElement.textContent = 'Keep studying! Focus on understanding HOCs, Render Props, Compound Components, Custom Hooks, and performance optimization techniques.';
            }

            // Show explanations for incorrect answers
            results.forEach(result => {
                if (!result.isCorrect) {
                    const questionElement = document.querySelector(`[data-question="${result.question}"]`);
                    const explanationDiv = document.createElement('div');
                    explanationDiv.className = 'explanation';
                    explanationDiv.innerHTML = `
                        <h4>Question ${result.question} Explanation:</h4>
                        <p>${result.explanation}</p>
                    `;
                    questionElement.appendChild(explanationDiv);
                }
            });
        }

        // Form submission
        document.getElementById('assessmentForm').addEventListener('submit', (e) => {
            e.preventDefault();
            submitAssessment();
        });

        // Initialize progress
        updateProgress();
    </script>
</body>
</html>
