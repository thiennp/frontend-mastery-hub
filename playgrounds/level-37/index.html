<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 37: AI/ML Integration</title>
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="level37-styles.css">
</head>
<body>
    <div class="level-container">
        <header class="level-header">
            <h1>ü§ñ Level 37: AI/ML Integration</h1>
            <p>Master Machine Learning APIs, TensorFlow.js, Computer Vision, Natural Language Processing, and AI-powered Features</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="level-stats">
                <span>Exercises: <span id="completedExercises">0</span>/5</span>
                <span>Badges: <span id="badgeCount">0</span></span>
            </div>
        </header>

        <div class="exercises-container">
            <!-- Exercise 1: Machine Learning APIs -->
            <div class="exercise" id="exercise1">
                <h2>üß† Exercise 1: Machine Learning APIs</h2>
                <p>Implement ML API integration with prediction, classification, and recommendation systems.</p>
                
                <div class="code-editor">
                    <h3>ML API Manager</h3>
                    <textarea id="code1" placeholder="Implement ML API integration...">// Machine Learning API Manager
class MLAPIManager {
  constructor() {
    this.apis = new Map();
    this.models = new Map();
    this.predictions = new Map();
  }

  // Text Classification API
  async classifyText(text, categories) {
    const classification = {
      text,
      categories: categories || ['positive', 'negative', 'neutral'],
      confidence: Math.random() * 0.4 + 0.6, // 60-100%
      prediction: categories[Math.floor(Math.random() * categories.length)],
      timestamp: new Date()
    };
    
    this.predictions.set(`text_${Date.now()}`, classification);
    console.log('Text classified:', classification);
    return classification;
  }

  // Image Recognition API
  async recognizeImage(imageData) {
    const recognition = {
      image: imageData,
      objects: this.generateRandomObjects(),
      confidence: Math.random() * 0.3 + 0.7, // 70-100%
      timestamp: new Date()
    };
    
    this.predictions.set(`image_${Date.now()}`, recognition);
    console.log('Image recognized:', recognition);
    return recognition;
  }

  generateRandomObjects() {
    const objects = ['person', 'car', 'dog', 'cat', 'tree', 'building', 'bicycle'];
    const count = Math.floor(Math.random() * 3) + 1;
    return objects.slice(0, count);
  }

  // Recommendation Engine
  async generateRecommendations(userId, preferences) {
    const recommendations = {
      userId,
      preferences,
      items: this.generateRecommendedItems(preferences),
      score: Math.random() * 0.4 + 0.6, // 60-100%
      timestamp: new Date()
    };
    
    this.predictions.set(`rec_${userId}`, recommendations);
    console.log('Recommendations generated:', recommendations);
    return recommendations;
  }

  generateRecommendedItems(preferences) {
    const items = ['movie', 'book', 'product', 'song', 'article'];
    return items.slice(0, Math.floor(Math.random() * 3) + 2);
  }

  // Sentiment Analysis
  async analyzeSentiment(text) {
    const sentiment = {
      text,
      sentiment: this.calculateSentiment(text),
      confidence: Math.random() * 0.3 + 0.7,
      emotions: this.extractEmotions(text),
      timestamp: new Date()
    };
    
    this.predictions.set(`sentiment_${Date.now()}`, sentiment);
    console.log('Sentiment analyzed:', sentiment);
    return sentiment;
  }

  calculateSentiment(text) {
    const positiveWords = ['good', 'great', 'excellent', 'amazing', 'love'];
    const negativeWords = ['bad', 'terrible', 'awful', 'hate', 'disappointed'];
    
    const words = text.toLowerCase().split(' ');
    const positiveCount = words.filter(word => positiveWords.includes(word)).length;
    const negativeCount = words.filter(word => negativeWords.includes(word)).length;
    
    if (positiveCount > negativeCount) return 'positive';
    if (negativeCount > positiveCount) return 'negative';
    return 'neutral';
  }

  extractEmotions(text) {
    const emotions = ['joy', 'sadness', 'anger', 'fear', 'surprise'];
    return emotions.slice(0, Math.floor(Math.random() * 2) + 1);
  }

  // Language Translation
  async translateText(text, targetLanguage) {
    const translation = {
      originalText: text,
      translatedText: this.simulateTranslation(text, targetLanguage),
      sourceLanguage: 'en',
      targetLanguage,
      confidence: Math.random() * 0.2 + 0.8, // 80-100%
      timestamp: new Date()
    };
    
    this.predictions.set(`translation_${Date.now()}`, translation);
    console.log('Text translated:', translation);
    return translation;
  }

  simulateTranslation(text, targetLanguage) {
    return `[${targetLanguage}] ${text}`;
  }

  // Get Prediction History
  getPredictionHistory() {
    const history = [];
    for (const [id, prediction] of this.predictions.entries()) {
      history.push({ id, ...prediction });
    }
    return history;
  }
}

// Create ML API Manager
const mlAPI = new MLAPIManager();

// Example usage
mlAPI.classifyText('This is a great product!', ['positive', 'negative']);
mlAPI.recognizeImage('image_data_here');
mlAPI.generateRecommendations('user123', ['movies', 'books']);
mlAPI.analyzeSentiment('I love this new feature!');
mlAPI.translateText('Hello world', 'es');

console.log('ML API Manager initialized');</textarea>
                </div>
                
                <div class="exercise-controls">
                    <button onclick="runCode(1)">Run Code</button>
                    <button onclick="validateExercise(1)">Validate</button>
                </div>
                
                <div class="output" id="output1"></div>
                <div class="hint" id="hint1">
                    <strong>Hint:</strong> Focus on ML API integration for text classification, image recognition, and recommendation systems.
                </div>
            </div>

            <!-- Exercise 2: TensorFlow.js -->
            <div class="exercise" id="exercise2">
                <h2>üî¨ Exercise 2: TensorFlow.js</h2>
                <p>Implement client-side machine learning with TensorFlow.js models and neural networks.</p>
                
                <div class="code-editor">
                    <h3>TensorFlow.js Model Manager</h3>
                    <textarea id="code2" placeholder="Implement TensorFlow.js models...">// TensorFlow.js Model Manager
class TensorFlowManager {
  constructor() {
    this.models = new Map();
    this.trainingData = new Map();
    this.predictions = new Map();
  }

  // Create Simple Neural Network
  createNeuralNetwork(inputSize, hiddenSize, outputSize) {
    const model = {
      id: `model_${Date.now()}`,
      inputSize,
      hiddenSize,
      outputSize,
      layers: this.createLayers(inputSize, hiddenSize, outputSize),
      weights: this.initializeWeights(inputSize, hiddenSize, outputSize),
      biases: this.initializeBiases(hiddenSize, outputSize),
      status: 'created'
    };
    
    this.models.set(model.id, model);
    console.log('Neural network created:', model);
    return model;
  }

  createLayers(inputSize, hiddenSize, outputSize) {
    return [
      { type: 'input', size: inputSize },
      { type: 'hidden', size: hiddenSize, activation: 'relu' },
      { type: 'output', size: outputSize, activation: 'softmax' }
    ];
  }

  initializeWeights(inputSize, hiddenSize, outputSize) {
    return {
      inputHidden: this.randomMatrix(inputSize, hiddenSize),
      hiddenOutput: this.randomMatrix(hiddenSize, outputSize)
    };
  }

  initializeBiases(hiddenSize, outputSize) {
    return {
      hidden: new Array(hiddenSize).fill(0.1),
      output: new Array(outputSize).fill(0.1)
    };
  }

  randomMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
      matrix[i] = [];
      for (let j = 0; j < cols; j++) {
        matrix[i][j] = Math.random() * 2 - 1; // -1 to 1
      }
    }
    return matrix;
  }

  // Load Pre-trained Model
  async loadPretrainedModel(modelType) {
    const model = {
      id: `pretrained_${modelType}_${Date.now()}`,
      type: modelType,
      status: 'loading',
      layers: this.getPretrainedLayers(modelType),
      metadata: this.getModelMetadata(modelType)
    };
    
    // Simulate loading
    setTimeout(() => {
      model.status = 'loaded';
      console.log('Pre-trained model loaded:', model);
    }, 1000);
    
    this.models.set(model.id, model);
    return model;
  }

  getPretrainedLayers(modelType) {
    const layerConfigs = {
      'mobilenet': [
        { type: 'conv2d', filters: 32, kernelSize: 3 },
        { type: 'maxpooling2d', poolSize: 2 },
        { type: 'conv2d', filters: 64, kernelSize: 3 },
        { type: 'globalaveragepooling2d' },
        { type: 'dense', units: 1000, activation: 'softmax' }
      ],
      'posenet': [
        { type: 'conv2d', filters: 16, kernelSize: 3 },
        { type: 'conv2d', filters: 32, kernelSize: 3 },
        { type: 'conv2d', filters: 64, kernelSize: 3 },
        { type: 'dense', units: 17, activation: 'sigmoid' }
      ]
    };
    
    return layerConfigs[modelType] || [];
  }

  getModelMetadata(modelType) {
    const metadata = {
      'mobilenet': {
        inputShape: [224, 224, 3],
        classes: 1000,
        description: 'Mobile-optimized image classification model'
      },
      'posenet': {
        inputShape: [257, 257, 3],
        keypoints: 17,
        description: 'Real-time human pose estimation model'
      }
    };
    
    return metadata[modelType] || {};
  }

  // Train Model
  async trainModel(modelId, trainingData, epochs = 10) {
    const model = this.models.get(modelId);
    if (!model) throw new Error('Model not found');
    
    model.status = 'training';
    model.trainingHistory = [];
    
    console.log(`Training model ${modelId} for ${epochs} epochs...`);
    
    for (let epoch = 0; epoch < epochs; epoch++) {
      const loss = this.calculateLoss(model, trainingData);
      const accuracy = this.calculateAccuracy(model, trainingData);
      
      model.trainingHistory.push({ epoch, loss, accuracy });
      
      // Simulate training progress
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    model.status = 'trained';
    console.log('Model training completed:', model.trainingHistory);
    return model;
  }

  calculateLoss(model, trainingData) {
    // Simplified loss calculation
    return Math.random() * 0.5 + 0.1; // 0.1 to 0.6
  }

  calculateAccuracy(model, trainingData) {
    // Simplified accuracy calculation
    return Math.random() * 0.3 + 0.7; // 0.7 to 1.0
  }

  // Make Predictions
  async predict(modelId, inputData) {
    const model = this.models.get(modelId);
    if (!model) throw new Error('Model not found');
    
    const prediction = {
      modelId,
      input: inputData,
      output: this.forwardPass(model, inputData),
      confidence: Math.random() * 0.3 + 0.7,
      timestamp: new Date()
    };
    
    this.predictions.set(`pred_${Date.now()}`, prediction);
    console.log('Prediction made:', prediction);
    return prediction;
  }

  forwardPass(model, input) {
    // Simplified forward pass
    const hidden = this.activate(input, model.weights.inputHidden, model.biases.hidden, 'relu');
    const output = this.activate(hidden, model.weights.hiddenOutput, model.biases.output, 'softmax');
    return output;
  }

  activate(input, weights, biases, activation) {
    const result = [];
    for (let i = 0; i < weights[0].length; i++) {
      let sum = biases[i];
      for (let j = 0; j < input.length; j++) {
        sum += input[j] * weights[j][i];
      }
      result[i] = this.applyActivation(sum, activation);
    }
    return result;
  }

  applyActivation(value, activation) {
    switch (activation) {
      case 'relu': return Math.max(0, value);
      case 'sigmoid': return 1 / (1 + Math.exp(-value));
      case 'softmax': return Math.exp(value) / (1 + Math.exp(value));
      default: return value;
    }
  }

  // Model Evaluation
  evaluateModel(modelId, testData) {
    const model = this.models.get(modelId);
    if (!model) throw new Error('Model not found');
    
    const evaluation = {
      modelId,
      accuracy: Math.random() * 0.2 + 0.8, // 0.8 to 1.0
      precision: Math.random() * 0.2 + 0.8,
      recall: Math.random() * 0.2 + 0.8,
      f1Score: Math.random() * 0.2 + 0.8,
      confusionMatrix: this.generateConfusionMatrix(testData.length),
      timestamp: new Date()
    };
    
    console.log('Model evaluation:', evaluation);
    return evaluation;
  }

  generateConfusionMatrix(size) {
    const matrix = [];
    for (let i = 0; i < size; i++) {
      matrix[i] = [];
      for (let j = 0; j < size; j++) {
        matrix[i][j] = Math.floor(Math.random() * 100);
      }
    }
    return matrix;
  }
}

// Create TensorFlow Manager
const tfManager = new TensorFlowManager();

// Example usage
tfManager.createNeuralNetwork(4, 8, 3);
tfManager.loadPretrainedModel('mobilenet');
tfManager.loadPretrainedModel('posenet');

console.log('TensorFlow.js Manager initialized');</textarea>
                </div>
                
                <div class="exercise-controls">
                    <button onclick="runCode(2)">Run Code</button>
                    <button onclick="validateExercise(2)">Validate</button>
                </div>
                
                <div class="output" id="output2"></div>
                <div class="hint" id="hint2">
                    <strong>Hint:</strong> Implement neural networks, pre-trained models, training, and prediction with TensorFlow.js.
                </div>
            </div>

            <!-- Exercise 3: Computer Vision -->
            <div class="exercise" id="exercise3">
                <h2>üëÅÔ∏è Exercise 3: Computer Vision</h2>
                <p>Implement computer vision features with object detection, face recognition, and image processing.</p>
                
                <div class="code-editor">
                    <h3>Computer Vision Manager</h3>
                    <textarea id="code3" placeholder="Implement computer vision features...">// Computer Vision Manager
class ComputerVisionManager {
  constructor() {
    this.detectors = new Map();
    this.processors = new Map();
    this.results = new Map();
  }

  // Object Detection
  async detectObjects(imageData) {
    const detection = {
      image: imageData,
      objects: this.generateObjectDetections(),
      confidence: Math.random() * 0.3 + 0.7,
      timestamp: new Date()
    };
    
    this.results.set(`detection_${Date.now()}`, detection);
    console.log('Objects detected:', detection);
    return detection;
  }

  generateObjectDetections() {
    const objects = [
      { class: 'person', confidence: 0.95, bbox: [100, 150, 200, 300] },
      { class: 'car', confidence: 0.87, bbox: [300, 200, 150, 100] },
      { class: 'dog', confidence: 0.82, bbox: [50, 250, 80, 120] }
    ];
    
    return objects.slice(0, Math.floor(Math.random() * 3) + 1);
  }

  // Face Recognition
  async recognizeFaces(imageData) {
    const recognition = {
      image: imageData,
      faces: this.generateFaceDetections(),
      landmarks: this.generateFacialLandmarks(),
      emotions: this.generateEmotionAnalysis(),
      timestamp: new Date()
    };
    
    this.results.set(`faces_${Date.now()}`, recognition);
    console.log('Faces recognized:', recognition);
    return recognition;
  }

  generateFaceDetections() {
    const faces = [
      { 
        id: 'face_1', 
        confidence: 0.92, 
        bbox: [120, 80, 150, 180],
        age: Math.floor(Math.random() * 50) + 20,
        gender: Math.random() > 0.5 ? 'male' : 'female'
      }
    ];
    
    return faces;
  }

  generateFacialLandmarks() {
    return {
      leftEye: [140, 120],
      rightEye: [200, 120],
      nose: [170, 150],
      leftMouth: [150, 180],
      rightMouth: [190, 180]
    };
  }

  generateEmotionAnalysis() {
    const emotions = ['happy', 'sad', 'angry', 'surprised', 'neutral'];
    return emotions[Math.floor(Math.random() * emotions.length)];
  }

  // Image Processing
  async processImage(imageData, operations) {
    const processedImage = {
      original: imageData,
      operations: operations,
      result: this.applyImageOperations(imageData, operations),
      metadata: this.generateImageMetadata(imageData),
      timestamp: new Date()
    };
    
    this.results.set(`processed_${Date.now()}`, processedImage);
    console.log('Image processed:', processedImage);
    return processedImage;
  }

  applyImageOperations(imageData, operations) {
    const result = { ...imageData };
    
    operations.forEach(op => {
      switch (op.type) {
        case 'blur':
          result.blur = op.intensity || 5;
          break;
        case 'brightness':
          result.brightness = op.value || 1.2;
          break;
        case 'contrast':
          result.contrast = op.value || 1.1;
          break;
        case 'resize':
          result.width = op.width || imageData.width;
          result.height = op.height || imageData.height;
          break;
        case 'crop':
          result.crop = op.region || [0, 0, imageData.width, imageData.height];
          break;
      }
    });
    
    return result;
  }

  generateImageMetadata(imageData) {
    return {
      width: imageData.width || 800,
      height: imageData.height || 600,
      format: imageData.format || 'jpeg',
      size: Math.floor(Math.random() * 1000) + 100, // KB
      colorspace: 'RGB',
      channels: 3
    };
  }

  // OCR (Optical Character Recognition)
  async extractText(imageData) {
    const ocrResult = {
      image: imageData,
      text: this.generateRandomText(),
      confidence: Math.random() * 0.3 + 0.7,
      boundingBoxes: this.generateTextBoundingBoxes(),
      language: 'en',
      timestamp: new Date()
    };
    
    this.results.set(`ocr_${Date.now()}`, ocrResult);
    console.log('Text extracted:', ocrResult);
    return ocrResult;
  }

  generateRandomText() {
    const texts = [
      'Hello World!',
      'Welcome to AI/ML Integration',
      'Computer Vision is amazing',
      'Machine Learning rocks!'
    ];
    
    return texts[Math.floor(Math.random() * texts.length)];
  }

  generateTextBoundingBoxes() {
    return [
      { text: 'Hello', bbox: [50, 100, 80, 30] },
      { text: 'World!', bbox: [140, 100, 70, 30] }
    ];
  }

  // Image Classification
  async classifyImage(imageData) {
    const classification = {
      image: imageData,
      classes: this.generateImageClasses(),
      confidence: Math.random() * 0.3 + 0.7,
      timestamp: new Date()
    };
    
    this.results.set(`classification_${Date.now()}`, classification);
    console.log('Image classified:', classification);
    return classification;
  }

  generateImageClasses() {
    const classes = [
      { name: 'landscape', confidence: 0.85 },
      { name: 'portrait', confidence: 0.12 },
      { name: 'abstract', confidence: 0.03 }
    ];
    
    return classes;
  }

  // Get All Results
  getAllResults() {
    const results = [];
    for (const [id, result] of this.results.entries()) {
      results.push({ id, ...result });
    }
    return results;
  }
}

// Create Computer Vision Manager
const cvManager = new ComputerVisionManager();

// Example usage
cvManager.detectObjects('image_data');
cvManager.recognizeFaces('face_image_data');
cvManager.processImage('image_data', [
  { type: 'blur', intensity: 5 },
  { type: 'brightness', value: 1.2 }
]);
cvManager.extractText('text_image_data');
cvManager.classifyImage('classification_image_data');

console.log('Computer Vision Manager initialized');</textarea>
                </div>
                
                <div class="exercise-controls">
                    <button onclick="runCode(3)">Run Code</button>
                    <button onclick="validateExercise(3)">Validate</button>
                </div>
                
                <div class="output" id="output3"></div>
                <div class="hint" id="hint3">
                    <strong>Hint:</strong> Implement object detection, face recognition, image processing, OCR, and image classification.
                </div>
            </div>

            <!-- Exercise 4: Natural Language Processing -->
            <div class="exercise" id="exercise4">
                <h2>üí¨ Exercise 4: Natural Language Processing</h2>
                <p>Implement NLP features with text analysis, language understanding, and text generation.</p>
                
                <div class="code-editor">
                    <h3>NLP Manager</h3>
                    <textarea id="code4" placeholder="Implement NLP features...">// Natural Language Processing Manager
class NLPManager {
  constructor() {
    this.processors = new Map();
    this.models = new Map();
    this.results = new Map();
  }

  // Text Preprocessing
  preprocessText(text) {
    const processed = {
      original: text,
      cleaned: this.cleanText(text),
      tokens: this.tokenize(text),
      lemmatized: this.lemmatize(text),
      stopWordsRemoved: this.removeStopWords(text),
      timestamp: new Date()
    };
    
    console.log('Text preprocessed:', processed);
    return processed;
  }

  cleanText(text) {
    return text
      .toLowerCase()
      .replace(/[^\w\s]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }

  tokenize(text) {
    return text.split(' ').filter(token => token.length > 0);
  }

  lemmatize(text) {
    // Simplified lemmatization
    const lemmatized = text
      .replace(/ing\b/g, '')
      .replace(/ed\b/g, '')
      .replace(/s\b/g, '');
    return lemmatized;
  }

  removeStopWords(text) {
    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
    const tokens = this.tokenize(text);
    return tokens.filter(token => !stopWords.includes(token));
  }

  // Named Entity Recognition
  async extractEntities(text) {
    const entities = {
      text,
      entities: this.generateEntities(text),
      confidence: Math.random() * 0.3 + 0.7,
      timestamp: new Date()
    };
    
    this.results.set(`entities_${Date.now()}`, entities);
    console.log('Entities extracted:', entities);
    return entities;
  }

  generateEntities(text) {
    const entities = [
      { text: 'John Doe', type: 'PERSON', confidence: 0.95 },
      { text: 'New York', type: 'LOCATION', confidence: 0.92 },
      { text: 'Apple Inc.', type: 'ORGANIZATION', confidence: 0.88 },
      { text: '2024', type: 'DATE', confidence: 0.85 }
    ];
    
    return entities.slice(0, Math.floor(Math.random() * 3) + 1);
  }

  // Text Summarization
  async summarizeText(text, maxLength = 100) {
    const summary = {
      original: text,
      summary: this.generateSummary(text, maxLength),
      compressionRatio: this.calculateCompressionRatio(text, maxLength),
      keyPhrases: this.extractKeyPhrases(text),
      timestamp: new Date()
    };
    
    this.results.set(`summary_${Date.now()}`, summary);
    console.log('Text summarized:', summary);
    return summary;
  }

  generateSummary(text, maxLength) {
    const sentences = text.split('.');
    const summary = sentences.slice(0, 2).join('.') + '.';
    return summary.length > maxLength ? summary.substring(0, maxLength) + '...' : summary;
  }

  calculateCompressionRatio(original, summary) {
    return (summary.length / original.length) * 100;
  }

  extractKeyPhrases(text) {
    const phrases = ['machine learning', 'artificial intelligence', 'natural language processing', 'computer vision'];
    return phrases.slice(0, Math.floor(Math.random() * 2) + 1);
  }

  // Language Detection
  async detectLanguage(text) {
    const detection = {
      text,
      language: this.identifyLanguage(text),
      confidence: Math.random() * 0.3 + 0.7,
      alternatives: this.generateLanguageAlternatives(),
      timestamp: new Date()
    };
    
    this.results.set(`language_${Date.now()}`, detection);
    console.log('Language detected:', detection);
    return detection;
  }

  identifyLanguage(text) {
    const languages = ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'zh', 'ja', 'ko'];
    return languages[Math.floor(Math.random() * languages.length)];
  }

  generateLanguageAlternatives() {
    return [
      { language: 'en', confidence: 0.85 },
      { language: 'es', confidence: 0.10 },
      { language: 'fr', confidence: 0.05 }
    ];
  }

  // Text Generation
  async generateText(prompt, maxLength = 100) {
    const generated = {
      prompt,
      generatedText: this.generateTextFromPrompt(prompt, maxLength),
      length: maxLength,
      creativity: Math.random() * 0.5 + 0.5, // 0.5 to 1.0
      timestamp: new Date()
    };
    
    this.results.set(`generated_${Date.now()}`, generated);
    console.log('Text generated:', generated);
    return generated;
  }

  generateTextFromPrompt(prompt, maxLength) {
    const responses = [
      'This is a generated response based on your prompt.',
      'The AI has processed your input and generated this text.',
      'Based on the context, here is what the AI thinks.',
      'This generated text follows the pattern of your prompt.'
    ];
    
    const response = responses[Math.floor(Math.random() * responses.length)];
    return response.length > maxLength ? response.substring(0, maxLength) + '...' : response;
  }

  // Question Answering
  async answerQuestion(question, context) {
    const answer = {
      question,
      context,
      answer: this.generateAnswer(question, context),
      confidence: Math.random() * 0.3 + 0.7,
      source: this.findAnswerSource(question, context),
      timestamp: new Date()
    };
    
    this.results.set(`answer_${Date.now()}`, answer);
    console.log('Question answered:', answer);
    return answer;
  }

  generateAnswer(question, context) {
    const answers = [
      'Based on the context provided, the answer is...',
      'The information suggests that...',
      'According to the given context...',
      'The answer can be found in the text...'
    ];
    
    return answers[Math.floor(Math.random() * answers.length)];
  }

  findAnswerSource(question, context) {
    return context.substring(0, 50) + '...';
  }

  // Get All Results
  getAllResults() {
    const results = [];
    for (const [id, result] of this.results.entries()) {
      results.push({ id, ...result });
    }
    return results;
  }
}

// Create NLP Manager
const nlpManager = new NLPManager();

// Example usage
nlpManager.preprocessText('Hello world! This is a test.');
nlpManager.extractEntities('John Doe works at Apple Inc. in New York.');
nlpManager.summarizeText('This is a long text that needs to be summarized...');
nlpManager.detectLanguage('Bonjour le monde!');
nlpManager.generateText('Write about artificial intelligence');
nlpManager.answerQuestion('What is machine learning?', 'Machine learning is a subset of AI...');

console.log('NLP Manager initialized');</textarea>
                </div>
                
                <div class="exercise-controls">
                    <button onclick="runCode(4)">Run Code</button>
                    <button onclick="validateExercise(4)">Validate</button>
                </div>
                
                <div class="output" id="output4"></div>
                <div class="hint" id="hint4">
                    <strong>Hint:</strong> Implement text preprocessing, entity extraction, summarization, language detection, and text generation.
                </div>
            </div>

            <!-- Exercise 5: AI-powered Features -->
            <div class="exercise" id="exercise5">
                <h2>üöÄ Exercise 5: AI-powered Features</h2>
                <p>Implement AI-powered features with chatbots, recommendation systems, and intelligent automation.</p>
                
                <div class="code-editor">
                    <h3>AI Features Manager</h3>
                    <textarea id="code5" placeholder="Implement AI-powered features...">// AI-powered Features Manager
class AIFeaturesManager {
  constructor() {
    this.features = new Map();
    this.chatbots = new Map();
    this.recommendations = new Map();
    this.automations = new Map();
  }

  // Chatbot System
  createChatbot(name, personality) {
    const chatbot = {
      id: `chatbot_${Date.now()}`,
      name,
      personality: personality || 'friendly',
      responses: this.generateResponses(personality),
      context: {},
      status: 'active',
      timestamp: new Date()
    };
    
    this.chatbots.set(chatbot.id, chatbot);
    console.log('Chatbot created:', chatbot);
    return chatbot;
  }

  generateResponses(personality) {
    const responseTemplates = {
      friendly: [
        'Hello! How can I help you today?',
        'That sounds interesting! Tell me more.',
        'I\'m here to assist you with anything you need.',
        'Great question! Let me help you with that.'
      ],
      professional: [
        'Good day. How may I assist you?',
        'I understand your inquiry. Let me provide you with the information.',
        'Thank you for your question. Here\'s what I can tell you.',
        'I\'ll do my best to help you with your request.'
      ],
      casual: [
        'Hey there! What\'s up?',
        'Cool! Tell me more about that.',
        'I\'m totally here to help you out.',
        'That\'s awesome! Let\'s figure this out together.'
      ]
    };
    
    return responseTemplates[personality] || responseTemplates.friendly;
  }

  async chatWithBot(botId, message) {
    const chatbot = this.chatbots.get(botId);
    if (!chatbot) throw new Error('Chatbot not found');
    
    const response = {
      botId,
      userMessage: message,
      botResponse: this.generateBotResponse(chatbot, message),
      context: this.updateContext(chatbot.context, message),
      timestamp: new Date()
    };
    
    chatbot.context = response.context;
    console.log('Chat response:', response);
    return response;
  }

  generateBotResponse(chatbot, message) {
    const responses = chatbot.responses;
    return responses[Math.floor(Math.random() * responses.length)];
  }

  updateContext(context, message) {
    return {
      ...context,
      lastMessage: message,
      messageCount: (context.messageCount || 0) + 1,
      lastInteraction: new Date()
    };
  }

  // Recommendation System
  createRecommendationEngine(type, algorithm) {
    const engine = {
      id: `rec_engine_${Date.now()}`,
      type: type || 'collaborative',
      algorithm: algorithm || 'matrix_factorization',
      users: new Map(),
      items: new Map(),
      ratings: new Map(),
      status: 'active',
      timestamp: new Date()
    };
    
    this.recommendations.set(engine.id, engine);
    console.log('Recommendation engine created:', engine);
    return engine;
  }

  async generateRecommendations(engineId, userId, count = 5) {
    const engine = this.recommendations.get(engineId);
    if (!engine) throw new Error('Recommendation engine not found');
    
    const recommendations = {
      engineId,
      userId,
      recommendations: this.generateUserRecommendations(engine, userId, count),
      confidence: Math.random() * 0.3 + 0.7,
      algorithm: engine.algorithm,
      timestamp: new Date()
    };
    
    console.log('Recommendations generated:', recommendations);
    return recommendations;
  }

  generateUserRecommendations(engine, userId, count) {
    const items = ['movie', 'book', 'song', 'product', 'article', 'game', 'app'];
    const recommendations = [];
    
    for (let i = 0; i < count; i++) {
      recommendations.push({
        item: items[Math.floor(Math.random() * items.length)],
        score: Math.random() * 0.4 + 0.6, // 0.6 to 1.0
        reason: this.generateRecommendationReason()
      });
    }
    
    return recommendations;
  }

  generateRecommendationReason() {
    const reasons = [
      'Based on your viewing history',
      'Similar users also liked',
      'Trending in your area',
      'Matches your preferences',
      'Popular this week'
    ];
    
    return reasons[Math.floor(Math.random() * reasons.length)];
  }

  // Intelligent Automation
  createAutomationRule(name, trigger, action) {
    const rule = {
      id: `automation_${Date.now()}`,
      name,
      trigger: trigger || 'user_action',
      action: action || 'send_notification',
      conditions: this.generateConditions(trigger),
      status: 'active',
      executions: 0,
      timestamp: new Date()
    };
    
    this.automations.set(rule.id, rule);
    console.log('Automation rule created:', rule);
    return rule;
  }

  generateConditions(trigger) {
    const conditions = {
      'user_action': ['user_logs_in', 'user_makes_purchase', 'user_views_item'],
      'time_based': ['daily_at_9am', 'weekly_on_monday', 'monthly_on_1st'],
      'data_based': ['new_data_available', 'threshold_exceeded', 'pattern_detected']
    };
    
    return conditions[trigger] || conditions['user_action'];
  }

  async executeAutomation(ruleId, context) {
    const rule = this.automations.get(ruleId);
    if (!rule) throw new Error('Automation rule not found');
    
    const execution = {
      ruleId,
      context,
      action: this.performAction(rule.action, context),
      success: Math.random() > 0.1, // 90% success rate
      timestamp: new Date()
    };
    
    rule.executions++;
    console.log('Automation executed:', execution);
    return execution;
  }

  performAction(action, context) {
    const actions = {
      'send_notification': 'Notification sent to user',
      'update_database': 'Database updated with new data',
      'send_email': 'Email sent to user',
      'trigger_workflow': 'Workflow triggered successfully',
      'generate_report': 'Report generated and saved'
    };
    
    return actions[action] || 'Action performed successfully';
  }

  // Smart Search
  async smartSearch(query, context) {
    const search = {
      query,
      context,
      results: this.generateSearchResults(query),
      suggestions: this.generateSearchSuggestions(query),
      filters: this.generateSearchFilters(query),
      confidence: Math.random() * 0.3 + 0.7,
      timestamp: new Date()
    };
    
    console.log('Smart search performed:', search);
    return search;
  }

  generateSearchResults(query) {
    const results = [
      { title: `Result for "${query}"`, relevance: 0.95, type: 'document' },
      { title: `Related to "${query}"`, relevance: 0.87, type: 'article' },
      { title: `About "${query}"`, relevance: 0.82, type: 'video' }
    ];
    
    return results.slice(0, Math.floor(Math.random() * 3) + 1);
  }

  generateSearchSuggestions(query) {
    return [
      `${query} tutorial`,
      `${query} examples`,
      `${query} best practices`,
      `how to ${query}`
    ];
  }

  generateSearchFilters(query) {
    return [
      { name: 'Type', options: ['All', 'Articles', 'Videos', 'Tutorials'] },
      { name: 'Date', options: ['All', 'Last week', 'Last month', 'Last year'] },
      { name: 'Language', options: ['All', 'English', 'Spanish', 'French'] }
    ];
  }

  // Get All Features
  getAllFeatures() {
    return {
      chatbots: Array.from(this.chatbots.values()),
      recommendations: Array.from(this.recommendations.values()),
      automations: Array.from(this.automations.values())
    };
  }
}

// Create AI Features Manager
const aiFeatures = new AIFeaturesManager();

// Example usage
aiFeatures.createChatbot('Assistant', 'friendly');
aiFeatures.createRecommendationEngine('collaborative', 'matrix_factorization');
aiFeatures.createAutomationRule('Daily Report', 'time_based', 'generate_report');
aiFeatures.smartSearch('machine learning', 'technical');

console.log('AI Features Manager initialized');</textarea>
                </div>
                
                <div class="exercise-controls">
                    <button onclick="runCode(5)">Run Code</button>
                    <button onclick="validateExercise(5)">Validate</button>
                </div>
                
                <div class="output" id="output5"></div>
                <div class="hint" id="hint5">
                    <strong>Hint:</strong> Implement chatbots, recommendation systems, intelligent automation, and smart search features.
                </div>
            </div>
        </div>

        <div class="level-navigation">
            <button onclick="goToLevel(36)" class="nav-btn prev">‚Üê Previous Level</button>
            <button onclick="goToLevel(38)" class="nav-btn next">Next Level ‚Üí</button>
        </div>
    </div>

    <script src="../../script.js"></script>
    <script src="level37-script.js"></script>
</body>
</html>
