<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Async Patterns Examples - Level 5</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; }
        .example { background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .example h3 { color: #333; border-bottom: 2px solid #6f42c1; padding-bottom: 10px; }
        .code-block { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; margin: 10px 0; overflow-x: auto; }
        .output { background: #e8f5e8; border: 1px solid #28a745; border-radius: 4px; padding: 10px; margin: 10px 0; font-family: monospace; }
        button { background: #6f42c1; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #5a32a3; }
    </style>
</head>
<body>
    <h1>Advanced Async Patterns Examples - Level 5</h1>
    <p>These examples demonstrate advanced asynchronous programming patterns.</p>

    <!-- Example 1: Promise Cancellation -->
    <div class="example">
        <h3>1. Promise Cancellation</h3>
        <div class="code-block">
            <pre><code>// AbortController for fetch
async function fetchWithCancellation(url, signal) {
    const response = await fetch(url, { signal });
    if (signal.aborted) throw new Error('Request cancelled');
    return response;
}

// Custom cancellable promise
class CancellablePromise extends Promise {
    constructor(executor) {
        super(executor);
        this.isCancelled = false;
    }
    cancel() { this.isCancelled = true; }
}</code></pre>
        </div>
        <button onclick="runPromiseCancellation()">Run Example</button>
        <div id="promiseCancellationOutput" class="output"></div>
    </div>

    <!-- Example 2: Retry Logic -->
    <div class="example">
        <h3>2. Retry Logic with Exponential Backoff</h3>
        <div class="code-block">
            <pre><code>async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            if (attempt === maxRetries) throw error;
            const delay = baseDelay * Math.pow(2, attempt - 1);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}</code></pre>
        </div>
        <button onclick="runRetryLogic()">Run Example</button>
        <div id="retryLogicOutput" class="output"></div>
    </div>

    <!-- Example 3: Circuit Breaker -->
    <div class="example">
        <h3>3. Circuit Breaker Pattern</h3>
        <div class="code-block">
            <pre><code>class CircuitBreaker {
    constructor(threshold = 5, timeout = 60000) {
        this.threshold = threshold;
        this.timeout = timeout;
        this.failureCount = 0;
        this.state = 'CLOSED';
    }
    
    async execute(fn) {
        if (this.state === 'OPEN') throw new Error('Circuit breaker is OPEN');
        try {
            const result = await fn();
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }
}</code></pre>
        </div>
        <button onclick="runCircuitBreaker()">Run Example</button>
        <div id="circuitBreakerOutput" class="output"></div>
    </div>

    <!-- Example 4: Rate Limiting -->
    <div class="example">
        <h3>4. Rate Limiting</h3>
        <div class="code-block">
            <pre><code>class RateLimiter {
    constructor(limit = 100, window = 60000) {
        this.limit = limit;
        this.window = window;
        this.requests = [];
    }
    
    async isAllowed() {
        const now = Date.now();
        this.requests = this.requests.filter(time => time > now - this.window);
        if (this.requests.length >= this.limit) return false;
        this.requests.push(now);
        return true;
    }
}</code></pre>
        </div>
        <button onclick="runRateLimiting()">Run Example</button>
        <div id="rateLimitingOutput" class="output"></div>
    </div>

    <!-- Example 5: Async Generators -->
    <div class="example">
        <h3>5. Async Generators</h3>
        <div class="code-block">
            <pre><code>async function* fetchDataStream(items) {
    for (const item of items) {
        try {
            const data = await fetchData(item);
            yield data;
        } catch (error) {
            console.error(`Failed to fetch ${item}:`, error);
        }
    }
}

// Usage
for await (const data of fetchDataStream([1, 2, 3, 4, 5])) {
    console.log('Received:', data);
}</code></pre>
        </div>
        <button onclick="runAsyncGenerators()">Run Example</button>
        <div id="asyncGeneratorsOutput" class="output"></div>
    </div>

    <!-- Example 6: Worker Threads -->
    <div class="example">
        <h3>6. Worker Threads</h3>
        <div class="code-block">
            <pre><code>class WorkerManager {
    constructor(maxWorkers = 4) {
        this.maxWorkers = maxWorkers;
        this.workers = [];
        this.taskQueue = [];
    }
    
    async executeTask(task) {
        const worker = this.getAvailableWorker();
        if (!worker) {
            return this.queueTask(task);
        }
        return this.runTaskOnWorker(worker, task);
    }
}</code></pre>
        </div>
        <button onclick="runWorkerThreads()">Run Example</button>
        <div id="workerThreadsOutput" class="output"></div>
    </div>

    <!-- Example 7: Queue Management -->
    <div class="example">
        <h3>7. Queue Management</h3>
        <div class="code-block">
            <pre><code>class PriorityQueue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) {
        this.items.push(item);
        this.items.sort((a, b) => b.priority - a.priority);
    }
    
    dequeue() {
        return this.items.shift();
    }
}</code></pre>
        </div>
        <button onclick="runQueueManagement()">Run Example</button>
        <div id="queueManagementOutput" class="output"></div>
    </div>

    <!-- Example 8: Bulk Operations -->
    <div class="example">
        <h3>8. Bulk Operations and Batching</h3>
        <div class="code-block">
            <pre><code>class BatchProcessor {
    constructor(batchSize = 10) {
        this.batchSize = batchSize;
        this.batch = [];
    }
    
    async add(item) {
        return new Promise((resolve, reject) => {
            this.batch.push({ item, resolve, reject });
            if (this.batch.length >= this.batchSize) {
                this.processBatch();
            }
        });
    }
}</code></pre>
        </div>
        <button onclick="runBulkOperations()">Run Example</button>
        <div id="bulkOperationsOutput" class="output"></div>
    </div>

    <script>
        // Helper functions
        function fetchData(id) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (Math.random() < 0.1) {
                        reject(new Error(`Failed to fetch data ${id}`));
                    } else {
                        resolve({ id, data: `Data ${id}` });
                    }
                }, Math.random() * 500 + 200);
            });
        }

        // Example implementations
        function runPromiseCancellation() {
            const output = document.getElementById('promiseCancellationOutput');
            output.innerHTML = '';
            
            const controller = new AbortController();
            const promise = fetchWithCancellation('/api/data', controller.signal);
            
            setTimeout(() => controller.abort(), 1000);
            
            promise
                .then(result => output.innerHTML = 'Success: ' + JSON.stringify(result))
                .catch(error => output.innerHTML = 'Error: ' + error.message);
        }

        function runRetryLogic() {
            const output = document.getElementById('retryLogicOutput');
            output.innerHTML = '';
            
            let attempts = 0;
            const flakyFunction = () => {
                attempts++;
                if (attempts < 3) {
                    return Promise.reject(new Error('Temporary failure'));
                }
                return Promise.resolve('Success after retries');
            };
            
            retryWithBackoff(flakyFunction, 3, 500)
                .then(result => output.innerHTML = 'Result: ' + result)
                .catch(error => output.innerHTML = 'Error: ' + error.message);
        }

        function runCircuitBreaker() {
            const output = document.getElementById('circuitBreakerOutput');
            output.innerHTML = '';
            
            const circuitBreaker = new CircuitBreaker(3, 5000);
            let failures = 0;
            
            const flakyFunction = () => {
                failures++;
                if (failures < 5) {
                    return Promise.reject(new Error('Service unavailable'));
                }
                return Promise.resolve('Service recovered');
            };
            
            circuitBreaker.execute(flakyFunction)
                .then(result => output.innerHTML = 'Result: ' + result)
                .catch(error => output.innerHTML = 'Error: ' + error.message);
        }

        function runRateLimiting() {
            const output = document.getElementById('rateLimitingOutput');
            output.innerHTML = '';
            
            const rateLimiter = new RateLimiter(3, 1000);
            let allowed = 0;
            
            for (let i = 0; i < 5; i++) {
                rateLimiter.isAllowed().then(isAllowed => {
                    if (isAllowed) allowed++;
                    output.innerHTML = `Allowed: ${allowed}/5`;
                });
            }
        }

        function runAsyncGenerators() {
            const output = document.getElementById('asyncGeneratorsOutput');
            output.innerHTML = '';
            
            async function* fetchDataStream(items) {
                for (const item of items) {
                    try {
                        const data = await fetchData(item);
                        yield data;
                    } catch (error) {
                        console.error(`Failed to fetch ${item}:`, error);
                    }
                }
            }
            
            (async () => {
                const results = [];
                for await (const data of fetchDataStream([1, 2, 3, 4, 5])) {
                    results.push(data);
                }
                output.innerHTML = 'Results: ' + JSON.stringify(results);
            })();
        }

        function runWorkerThreads() {
            const output = document.getElementById('workerThreadsOutput');
            output.innerHTML = 'Worker threads example - check console for details';
        }

        function runQueueManagement() {
            const output = document.getElementById('queueManagementOutput');
            output.innerHTML = '';
            
            const queue = new PriorityQueue();
            queue.enqueue({ id: 1, priority: 3, name: 'High priority' });
            queue.enqueue({ id: 2, priority: 1, name: 'Low priority' });
            queue.enqueue({ id: 3, priority: 2, name: 'Medium priority' });
            
            const results = [];
            while (queue.items.length > 0) {
                results.push(queue.dequeue());
            }
            
            output.innerHTML = 'Queue order: ' + JSON.stringify(results.map(r => r.name));
        }

        function runBulkOperations() {
            const output = document.getElementById('bulkOperationsOutput');
            output.innerHTML = '';
            
            const processor = new BatchProcessor(3);
            const results = [];
            
            for (let i = 0; i < 5; i++) {
                processor.add(i).then(result => {
                    results.push(result);
                    output.innerHTML = 'Processed: ' + results.length + '/5';
                });
            }
        }

        // Helper classes
        class CircuitBreaker {
            constructor(threshold = 5, timeout = 60000) {
                this.threshold = threshold;
                this.timeout = timeout;
                this.failureCount = 0;
                this.state = 'CLOSED';
            }
            
            async execute(fn) {
                if (this.state === 'OPEN') throw new Error('Circuit breaker is OPEN');
                try {
                    const result = await fn();
                    this.onSuccess();
                    return result;
                } catch (error) {
                    this.onFailure();
                    throw error;
                }
            }
            
            onSuccess() {
                this.failureCount = 0;
                this.state = 'CLOSED';
            }
            
            onFailure() {
                this.failureCount++;
                if (this.failureCount >= this.threshold) {
                    this.state = 'OPEN';
                }
            }
        }

        class RateLimiter {
            constructor(limit = 100, window = 60000) {
                this.limit = limit;
                this.window = window;
                this.requests = [];
            }
            
            async isAllowed() {
                const now = Date.now();
                this.requests = this.requests.filter(time => time > now - this.window);
                if (this.requests.length >= this.limit) return false;
                this.requests.push(now);
                return true;
            }
        }

        class PriorityQueue {
            constructor() {
                this.items = [];
            }
            
            enqueue(item) {
                this.items.push(item);
                this.items.sort((a, b) => b.priority - a.priority);
            }
            
            dequeue() {
                return this.items.shift();
            }
        }

        class BatchProcessor {
            constructor(batchSize = 10) {
                this.batchSize = batchSize;
                this.batch = [];
            }
            
            async add(item) {
                return new Promise((resolve, reject) => {
                    this.batch.push({ item, resolve, reject });
                    if (this.batch.length >= this.batchSize) {
                        this.processBatch();
                    }
                });
            }
            
            async processBatch() {
                const currentBatch = this.batch.splice(0, this.batchSize);
                const results = await Promise.all(currentBatch.map(b => fetchData(b.item)));
                currentBatch.forEach((b, index) => b.resolve(results[index]));
            }
        }

        async function fetchWithCancellation(url, signal) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    if (signal.aborted) {
                        reject(new Error('Request cancelled'));
                    } else {
                        resolve({ url, data: 'Mock data' });
                    }
                }, 2000);
                
                if (signal.aborted) {
                    clearTimeout(timeout);
                    reject(new Error('Request cancelled'));
                }
            });
        }

        async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    if (attempt === maxRetries) throw error;
                    const delay = baseDelay * Math.pow(2, attempt - 1);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
    </script>
</body>
</html>

