<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Callbacks & Callback Hell Examples - Level 5</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .example {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .example h3 {
            color: #333;
            border-bottom: 2px solid #dc3545;
            padding-bottom: 10px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
        }
        .output {
            background: #e8f5e8;
            border: 1px solid #28a745;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #dc3545;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #c82333;
        }
        .good {
            border-left: 4px solid #28a745;
        }
        .bad {
            border-left: 4px solid #dc3545;
        }
    </style>
</head>
<body>
    <h1>Callbacks & Callback Hell Examples - Level 5</h1>
    <p>These examples demonstrate callback patterns and how to avoid callback hell.</p>

    <!-- Example 1: Basic Callbacks -->
    <div class="example">
        <h3>1. Basic Callback Patterns</h3>
        <p>This example shows different ways to use callbacks in JavaScript.</p>
        
        <div class="code-block">
            <pre><code>// Simple callback
function greet(name, callback) {
    console.log(`Hello, ${name}!`);
    if (callback) {
        callback();
    }
}

// Callback with parameters
function calculate(a, b, operation, callback) {
    const result = operation(a, b);
    callback(result);
}

// Error-first callback pattern
function divide(a, b, callback) {
    if (b === 0) {
        callback(new Error('Division by zero'), null);
    } else {
        callback(null, a / b);
    }
}</code></pre>
        </div>
        
        <button onclick="runBasicCallbacks()">Run Example</button>
        <div id="basicCallbacksOutput" class="output"></div>
    </div>

    <!-- Example 2: Callback Hell -->
    <div class="example bad">
        <h3>2. Callback Hell (Anti-pattern)</h3>
        <p>This example demonstrates the callback hell problem with nested callbacks.</p>
        
        <div class="code-block">
            <pre><code>// BAD: Callback hell
function getUserData(userId, callback) {
    // Simulate API call
    setTimeout(() => {
        const user = { id: userId, name: 'John Doe' };
        
        // Get user's posts
        getPosts(userId, (err, posts) => {
            if (err) {
                callback(err, null);
                return;
            }
            
            // Get user's comments
            getComments(userId, (err, comments) => {
                if (err) {
                    callback(err, null);
                    return;
                }
                
                // Get user's friends
                getFriends(userId, (err, friends) => {
                    if (err) {
                        callback(err, null);
                        return;
                    }
                    
                    // Finally return all data
                    callback(null, {
                        user,
                        posts,
                        comments,
                        friends
                    });
                });
            });
        });
    }, 1000);
}</code></pre>
        </div>
        
        <button onclick="runCallbackHell()">Run Example</button>
        <div id="callbackHellOutput" class="output"></div>
    </div>

    <!-- Example 3: Avoiding Callback Hell -->
    <div class="example good">
        <h3>3. Avoiding Callback Hell with Promises</h3>
        <p>This example shows how to refactor callback hell using Promises.</p>
        
        <div class="code-block">
            <pre><code>// GOOD: Using Promises
function getUserDataPromise(userId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const user = { id: userId, name: 'John Doe' };
            resolve(user);
        }, 1000);
    });
}

function getUserDataWithPromises(userId) {
    return getUserDataPromise(userId)
        .then(user => {
            return Promise.all([
                getPostsPromise(userId),
                getCommentsPromise(userId),
                getFriendsPromise(userId)
            ]).then(([posts, comments, friends]) => ({
                user,
                posts,
                comments,
                friends
            }));
        });
}</code></pre>
        </div>
        
        <button onclick="runPromiseSolution()">Run Example</button>
        <div id="promiseSolutionOutput" class="output"></div>
    </div>

    <!-- Example 4: Callback Utilities -->
    <div class="example">
        <h3>4. Callback Utilities and Patterns</h3>
        <p>This example demonstrates useful callback utilities and patterns.</p>
        
        <div class="code-block">
            <pre><code>// Callback utilities
class CallbackUtils {
    // Promisify a callback-based function
    static promisify(fn) {
        return function(...args) {
            return new Promise((resolve, reject) => {
                fn.call(this, ...args, (err, result) => {
                    if (err) reject(err);
                    else resolve(result);
                });
            });
        };
    }
    
    // Callback with timeout
    static withTimeout(fn, timeout, callback) {
        let completed = false;
        
        const timer = setTimeout(() => {
            if (!completed) {
                completed = true;
                callback(new Error('Operation timeout'), null);
            }
        }, timeout);
        
        fn((err, result) => {
            if (!completed) {
                completed = true;
                clearTimeout(timer);
                callback(err, result);
            }
        });
    }
    
    // Retry with callback
    static retry(fn, maxRetries, callback) {
        let attempts = 0;
        
        const attempt = () => {
            attempts++;
            fn((err, result) => {
                if (err && attempts < maxRetries) {
                    setTimeout(attempt, 1000 * attempts);
                } else {
                    callback(err, result);
                }
            });
        };
        
        attempt();
    }
}</code></pre>
        </div>
        
        <button onclick="runCallbackUtilities()">Run Example</button>
        <div id="callbackUtilitiesOutput" class="output"></div>
    </div>

    <!-- Example 5: Event-driven Callbacks -->
    <div class="example">
        <h3>5. Event-driven Callbacks</h3>
        <p>This example shows how to use callbacks with event-driven programming.</p>
        
        <div class="code-block">
            <pre><code>// Event emitter with callbacks
class EventEmitter {
    constructor() {
        this.events = {};
    }
    
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    
    emit(event, ...args) {
        if (this.events[event]) {
            this.events[event].forEach(callback => {
                try {
                    callback(...args);
                } catch (error) {
                    console.error('Callback error:', error);
                }
            });
        }
    }
    
    once(event, callback) {
        const onceCallback = (...args) => {
            callback(...args);
            this.off(event, onceCallback);
        };
        this.on(event, onceCallback);
    }
    
    off(event, callback) {
        if (this.events[event]) {
            this.events[event] = this.events[event].filter(cb => cb !== callback);
        }
    }
}</code></pre>
        </div>
        
        <button onclick="runEventDrivenCallbacks()">Run Example</button>
        <div id="eventDrivenOutput" class="output"></div>
    </div>

    <!-- Example 6: Callback Composition -->
    <div class="example">
        <h3>6. Callback Composition and Piping</h3>
        <p>This example demonstrates how to compose and pipe callbacks.</p>
        
        <div class="code-block">
            <pre><code>// Callback composition
function composeCallbacks(...callbacks) {
    return function(value, callback) {
        let index = 0;
        
        function next(err, result) {
            if (err) {
                callback(err, null);
                return;
            }
            
            if (index >= callbacks.length) {
                callback(null, result);
                return;
            }
            
            const currentCallback = callbacks[index++];
            currentCallback(result, next);
        }
        
        next(null, value);
    };
}

// Callback pipeline
function createPipeline(...steps) {
    return function(input, callback) {
        let current = input;
        
        function executeStep(stepIndex) {
            if (stepIndex >= steps.length) {
                callback(null, current);
                return;
            }
            
            const step = steps[stepIndex];
            step(current, (err, result) => {
                if (err) {
                    callback(err, null);
                } else {
                    current = result;
                    executeStep(stepIndex + 1);
                }
            });
        }
        
        executeStep(0);
    };
}</code></pre>
        </div>
        
        <button onclick="runCallbackComposition()">Run Example</button>
        <div id="callbackCompositionOutput" class="output"></div>
    </div>

    <!-- Example 7: Callback Error Handling -->
    <div class="example">
        <h3>7. Callback Error Handling Patterns</h3>
        <p>This example shows different error handling patterns for callbacks.</p>
        
        <div class="code-block">
            <pre><code>// Error handling patterns
class CallbackErrorHandler {
    // Error-first callback pattern
    static errorFirst(fn, callback) {
        fn((err, result) => {
            if (err) {
                callback(err, null);
            } else {
                callback(null, result);
            }
        });
    }
    
    // Callback with error recovery
    static withRecovery(fn, recoveryFn, callback) {
        fn((err, result) => {
            if (err) {
                recoveryFn(err, (recoveryErr, recoveryResult) => {
                    if (recoveryErr) {
                        callback(recoveryErr, null);
                    } else {
                        callback(null, recoveryResult);
                    }
                });
            } else {
                callback(null, result);
            }
        });
    }
    
    // Callback with retry logic
    static withRetry(fn, maxRetries, callback) {
        let attempts = 0;
        
        const attempt = () => {
            attempts++;
            fn((err, result) => {
                if (err && attempts < maxRetries) {
                    setTimeout(attempt, 1000 * attempts);
                } else {
                    callback(err, result);
                }
            });
        };
        
        attempt();
    }
}</code></pre>
        </div>
        
        <button onclick="runCallbackErrorHandling()">Run Example</button>
        <div id="callbackErrorHandlingOutput" class="output"></div>
    </div>

    <!-- Example 8: Modern Callback Alternatives -->
    <div class="example good">
        <h3>8. Modern Alternatives to Callbacks</h3>
        <p>This example shows modern alternatives to callbacks using Promises and async/await.</p>
        
        <div class="code-block">
            <pre><code>// Modern alternatives
class ModernAsync {
    // Promise-based approach
    static async getUserDataAsync(userId) {
        try {
            const user = await this.getUser(userId);
            const [posts, comments, friends] = await Promise.all([
                this.getPosts(userId),
                this.getComments(userId),
                this.getFriends(userId)
            ]);
            
            return { user, posts, comments, friends };
        } catch (error) {
            throw error;
        }
    }
    
    // Generator-based approach
    static* getUserDataGenerator(userId) {
        try {
            const user = yield this.getUser(userId);
            const posts = yield this.getPosts(userId);
            const comments = yield this.getComments(userId);
            const friends = yield this.getFriends(userId);
            
            return { user, posts, comments, friends };
        } catch (error) {
            throw error;
        }
    }
    
    // Observable-based approach
    static getUserDataObservable(userId) {
        return new Observable(observer => {
            this.getUser(userId)
                .then(user => {
                    observer.next({ type: 'user', data: user });
                    return this.getPosts(userId);
                })
                .then(posts => {
                    observer.next({ type: 'posts', data: posts });
                    return this.getComments(userId);
                })
                .then(comments => {
                    observer.next({ type: 'comments', data: comments });
                    return this.getFriends(userId);
                })
                .then(friends => {
                    observer.next({ type: 'friends', data: friends });
                    observer.complete();
                })
                .catch(error => observer.error(error));
        });
    }
}</code></pre>
        </div>
        
        <button onclick="runModernAlternatives()">Run Example</button>
        <div id="modernAlternativesOutput" class="output"></div>
    </div>

    <script>
        // Example 1: Basic Callbacks
        function runBasicCallbacks() {
            const output = document.getElementById('basicCallbacksOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Simple callback
            function greet(name, callback) {
                console.log(`Hello, ${name}!`);
                if (callback) {
                    callback();
                }
            }
            
            // Callback with parameters
            function calculate(a, b, operation, callback) {
                const result = operation(a, b);
                callback(result);
            }
            
            // Error-first callback pattern
            function divide(a, b, callback) {
                if (b === 0) {
                    callback(new Error('Division by zero'), null);
                } else {
                    callback(null, a / b);
                }
            }
            
            greet('World', () => console.log('Callback executed!'));
            
            calculate(5, 3, (a, b) => a + b, (result) => {
                console.log(`5 + 3 = ${result}`);
            });
            
            divide(10, 2, (err, result) => {
                if (err) {
                    console.log('Error:', err.message);
                } else {
                    console.log(`10 / 2 = ${result}`);
                }
            });
            
            divide(10, 0, (err, result) => {
                if (err) {
                    console.log('Error:', err.message);
                } else {
                    console.log(`10 / 0 = ${result}`);
                }
            });
            
            console.log = originalLog;
            output.innerHTML = logs.join('<br>');
        }

        // Example 2: Callback Hell
        function runCallbackHell() {
            const output = document.getElementById('callbackHellOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Simulate API calls
            function getPosts(userId, callback) {
                setTimeout(() => {
                    callback(null, [{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }]);
                }, 500);
            }
            
            function getComments(userId, callback) {
                setTimeout(() => {
                    callback(null, [{ id: 1, text: 'Comment 1' }, { id: 2, text: 'Comment 2' }]);
                }, 300);
            }
            
            function getFriends(userId, callback) {
                setTimeout(() => {
                    callback(null, [{ id: 1, name: 'Friend 1' }, { id: 2, name: 'Friend 2' }]);
                }, 400);
            }
            
            // Callback hell
            function getUserData(userId, callback) {
                console.log('Getting user data...');
                setTimeout(() => {
                    const user = { id: userId, name: 'John Doe' };
                    console.log('User retrieved:', user);
                    
                    getPosts(userId, (err, posts) => {
                        if (err) {
                            callback(err, null);
                            return;
                        }
                        console.log('Posts retrieved:', posts);
                        
                        getComments(userId, (err, comments) => {
                            if (err) {
                                callback(err, null);
                                return;
                            }
                            console.log('Comments retrieved:', comments);
                            
                            getFriends(userId, (err, friends) => {
                                if (err) {
                                    callback(err, null);
                                    return;
                                }
                                console.log('Friends retrieved:', friends);
                                
                                callback(null, {
                                    user,
                                    posts,
                                    comments,
                                    friends
                                });
                            });
                        });
                    });
                }, 1000);
            }
            
            getUserData(1, (err, result) => {
                if (err) {
                    console.log('Error:', err.message);
                } else {
                    console.log('Final result:', result);
                }
            });
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 3000);
        }

        // Example 3: Promise Solution
        function runPromiseSolution() {
            const output = document.getElementById('promiseSolutionOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Promise-based functions
            function getUserDataPromise(userId) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        const user = { id: userId, name: 'John Doe' };
                        resolve(user);
                    }, 1000);
                });
            }
            
            function getPostsPromise(userId) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve([{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }]);
                    }, 500);
                });
            }
            
            function getCommentsPromise(userId) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve([{ id: 1, text: 'Comment 1' }, { id: 2, text: 'Comment 2' }]);
                    }, 300);
                });
            }
            
            function getFriendsPromise(userId) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve([{ id: 1, name: 'Friend 1' }, { id: 2, name: 'Friend 2' }]);
                    }, 400);
                });
            }
            
            // Promise-based solution
            function getUserDataWithPromises(userId) {
                console.log('Getting user data with promises...');
                return getUserDataPromise(userId)
                    .then(user => {
                        console.log('User retrieved:', user);
                        return Promise.all([
                            getPostsPromise(userId),
                            getCommentsPromise(userId),
                            getFriendsPromise(userId)
                        ]).then(([posts, comments, friends]) => {
                            console.log('All data retrieved:', { posts, comments, friends });
                            return { user, posts, comments, friends };
                        });
                    });
            }
            
            getUserDataWithPromises(1)
                .then(result => {
                    console.log('Final result:', result);
                })
                .catch(error => {
                    console.log('Error:', error.message);
                });
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 3000);
        }

        // Example 4: Callback Utilities
        function runCallbackUtilities() {
            const output = document.getElementById('callbackUtilitiesOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Callback utilities
            class CallbackUtils {
                static promisify(fn) {
                    return function(...args) {
                        return new Promise((resolve, reject) => {
                            fn.call(this, ...args, (err, result) => {
                                if (err) reject(err);
                                else resolve(result);
                            });
                        });
                    };
                }
                
                static withTimeout(fn, timeout, callback) {
                    let completed = false;
                    
                    const timer = setTimeout(() => {
                        if (!completed) {
                            completed = true;
                            callback(new Error('Operation timeout'), null);
                        }
                    }, timeout);
                    
                    fn((err, result) => {
                        if (!completed) {
                            completed = true;
                            clearTimeout(timer);
                            callback(err, result);
                        }
                    });
                }
                
                static retry(fn, maxRetries, callback) {
                    let attempts = 0;
                    
                    const attempt = () => {
                        attempts++;
                        fn((err, result) => {
                            if (err && attempts < maxRetries) {
                                console.log(`Attempt ${attempts} failed, retrying...`);
                                setTimeout(attempt, 1000 * attempts);
                            } else {
                                callback(err, result);
                            }
                        });
                    };
                    
                    attempt();
                }
            }
            
            // Test promisify
            function callbackFunction(value, callback) {
                setTimeout(() => {
                    if (value < 0) {
                        callback(new Error('Negative value'), null);
                    } else {
                        callback(null, value * 2);
                    }
                }, 1000);
            }
            
            const promisifiedFunction = CallbackUtils.promisify(callbackFunction);
            
            promisifiedFunction(5)
                .then(result => console.log('Promisified result:', result))
                .catch(error => console.log('Promisified error:', error.message));
            
            // Test retry
            let retryAttempts = 0;
            function flakyFunction(callback) {
                retryAttempts++;
                if (retryAttempts < 3) {
                    callback(new Error('Temporary failure'), null);
                } else {
                    callback(null, 'Success after retries');
                }
            }
            
            CallbackUtils.retry(flakyFunction, 3, (err, result) => {
                if (err) {
                    console.log('Retry failed:', err.message);
                } else {
                    console.log('Retry succeeded:', result);
                }
            });
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 5000);
        }

        // Example 5: Event-driven Callbacks
        function runEventDrivenCallbacks() {
            const output = document.getElementById('eventDrivenOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Event emitter with callbacks
            class EventEmitter {
                constructor() {
                    this.events = {};
                }
                
                on(event, callback) {
                    if (!this.events[event]) {
                        this.events[event] = [];
                    }
                    this.events[event].push(callback);
                }
                
                emit(event, ...args) {
                    if (this.events[event]) {
                        this.events[event].forEach(callback => {
                            try {
                                callback(...args);
                            } catch (error) {
                                console.error('Callback error:', error);
                            }
                        });
                    }
                }
                
                once(event, callback) {
                    const onceCallback = (...args) => {
                        callback(...args);
                        this.off(event, onceCallback);
                    };
                    this.on(event, onceCallback);
                }
                
                off(event, callback) {
                    if (this.events[event]) {
                        this.events[event] = this.events[event].filter(cb => cb !== callback);
                    }
                }
            }
            
            const emitter = new EventEmitter();
            
            // Register event listeners
            emitter.on('data', (data) => {
                console.log('Data received:', data);
            });
            
            emitter.on('error', (error) => {
                console.log('Error occurred:', error.message);
            });
            
            emitter.once('complete', (result) => {
                console.log('Operation completed:', result);
            });
            
            // Simulate some events
            setTimeout(() => {
                emitter.emit('data', { id: 1, name: 'Test' });
            }, 1000);
            
            setTimeout(() => {
                emitter.emit('error', new Error('Something went wrong'));
            }, 2000);
            
            setTimeout(() => {
                emitter.emit('complete', { success: true });
            }, 3000);
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 4000);
        }

        // Example 6: Callback Composition
        function runCallbackComposition() {
            const output = document.getElementById('callbackCompositionOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Callback composition
            function composeCallbacks(...callbacks) {
                return function(value, callback) {
                    let index = 0;
                    
                    function next(err, result) {
                        if (err) {
                            callback(err, null);
                            return;
                        }
                        
                        if (index >= callbacks.length) {
                            callback(null, result);
                            return;
                        }
                        
                        const currentCallback = callbacks[index++];
                        currentCallback(result, next);
                    }
                    
                    next(null, value);
                };
            }
            
            // Callback pipeline
            function createPipeline(...steps) {
                return function(input, callback) {
                    let current = input;
                    
                    function executeStep(stepIndex) {
                        if (stepIndex >= steps.length) {
                            callback(null, current);
                            return;
                        }
                        
                        const step = steps[stepIndex];
                        step(current, (err, result) => {
                            if (err) {
                                callback(err, null);
                            } else {
                                current = result;
                                executeStep(stepIndex + 1);
                            }
                        });
                    }
                    
                    executeStep(0);
                };
            }
            
            // Example functions
            function addOne(value, callback) {
                setTimeout(() => {
                    callback(null, value + 1);
                }, 100);
            }
            
            function multiplyByTwo(value, callback) {
                setTimeout(() => {
                    callback(null, value * 2);
                }, 100);
            }
            
            function square(value, callback) {
                setTimeout(() => {
                    callback(null, value * value);
                }, 100);
            }
            
            // Test composition
            const composed = composeCallbacks(addOne, multiplyByTwo, square);
            composed(5, (err, result) => {
                if (err) {
                    console.log('Composition error:', err.message);
                } else {
                    console.log('Composition result:', result); // ((5 + 1) * 2)² = 144
                }
            });
            
            // Test pipeline
            const pipeline = createPipeline(addOne, multiplyByTwo, square);
            pipeline(3, (err, result) => {
                if (err) {
                    console.log('Pipeline error:', err.message);
                } else {
                    console.log('Pipeline result:', result); // ((3 + 1) * 2)² = 64
                }
            });
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 1000);
        }

        // Example 7: Callback Error Handling
        function runCallbackErrorHandling() {
            const output = document.getElementById('callbackErrorHandlingOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Error handling patterns
            class CallbackErrorHandler {
                static errorFirst(fn, callback) {
                    fn((err, result) => {
                        if (err) {
                            callback(err, null);
                        } else {
                            callback(null, result);
                        }
                    });
                }
                
                static withRecovery(fn, recoveryFn, callback) {
                    fn((err, result) => {
                        if (err) {
                            recoveryFn(err, (recoveryErr, recoveryResult) => {
                                if (recoveryErr) {
                                    callback(recoveryErr, null);
                                } else {
                                    callback(null, recoveryResult);
                                }
                            });
                        } else {
                            callback(null, result);
                        }
                    });
                }
                
                static withRetry(fn, maxRetries, callback) {
                    let attempts = 0;
                    
                    const attempt = () => {
                        attempts++;
                        fn((err, result) => {
                            if (err && attempts < maxRetries) {
                                console.log(`Attempt ${attempts} failed, retrying...`);
                                setTimeout(attempt, 1000 * attempts);
                            } else {
                                callback(err, result);
                            }
                        });
                    };
                    
                    attempt();
                }
            }
            
            // Test functions
            function flakyFunction(callback) {
                setTimeout(() => {
                    if (Math.random() < 0.7) {
                        callback(new Error('Random failure'), null);
                    } else {
                        callback(null, 'Success');
                    }
                }, 500);
            }
            
            function recoveryFunction(error, callback) {
                setTimeout(() => {
                    callback(null, 'Recovered from error');
                }, 200);
            }
            
            // Test error-first pattern
            CallbackErrorHandler.errorFirst(flakyFunction, (err, result) => {
                if (err) {
                    console.log('Error-first pattern error:', err.message);
                } else {
                    console.log('Error-first pattern success:', result);
                }
            });
            
            // Test recovery pattern
            CallbackErrorHandler.withRecovery(flakyFunction, recoveryFunction, (err, result) => {
                if (err) {
                    console.log('Recovery pattern error:', err.message);
                } else {
                    console.log('Recovery pattern result:', result);
                }
            });
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 2000);
        }

        // Example 8: Modern Alternatives
        function runModernAlternatives() {
            const output = document.getElementById('modernAlternativesOutput');
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = (...args) => {
                logs.push(args.join(' '));
                originalLog(...args);
            };
            
            // Modern alternatives
            class ModernAsync {
                static async getUserDataAsync(userId) {
                    try {
                        console.log('Getting user data with async/await...');
                        const user = await this.getUser(userId);
                        console.log('User retrieved:', user);
                        
                        const [posts, comments, friends] = await Promise.all([
                            this.getPosts(userId),
                            this.getComments(userId),
                            this.getFriends(userId)
                        ]);
                        
                        console.log('All data retrieved:', { posts, comments, friends });
                        return { user, posts, comments, friends };
                    } catch (error) {
                        console.log('Error in async/await:', error.message);
                        throw error;
                    }
                }
                
                static async getUser(userId) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve({ id: userId, name: 'John Doe' });
                        }, 1000);
                    });
                }
                
                static async getPosts(userId) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve([{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }]);
                        }, 500);
                    });
                }
                
                static async getComments(userId) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve([{ id: 1, text: 'Comment 1' }, { id: 2, text: 'Comment 2' }]);
                        }, 300);
                    });
                }
                
                static async getFriends(userId) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve([{ id: 1, name: 'Friend 1' }, { id: 2, name: 'Friend 2' }]);
                        }, 400);
                    });
                }
            }
            
            // Test async/await
            ModernAsync.getUserDataAsync(1)
                .then(result => {
                    console.log('Final async/await result:', result);
                })
                .catch(error => {
                    console.log('Async/await error:', error.message);
                });
            
            console.log = originalLog;
            
            setTimeout(() => {
                output.innerHTML = logs.join('<br>');
            }, 3000);
        }
    </script>
</body>
</html>

