<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 2 - Error Handling Examples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .example {
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #fd7e14;
            border-radius: 4px;
        }
        .output {
            background: #000;
            color: #0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        button {
            background: #fd7e14;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #e8650e;
        }
        .code {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            margin: 10px 0;
        }
        .error {
            color: #dc3545;
            font-weight: bold;
        }
        .success {
            color: #28a745;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Level 2 - Error Handling Examples</h1>
    
    <div class="example">
        <h3>1. Basic Error Handling</h3>
        <p>Demonstrates try-catch-finally blocks and error types</p>
        <button onclick="runBasicErrorExamples()">Run Examples</button>
        <div id="basic-error-output" class="output"></div>
    </div>

    <div class="example">
        <h3>2. Custom Error Classes</h3>
        <p>Demonstrates creating and using custom error classes</p>
        <button onclick="runCustomErrorExamples()">Run Examples</button>
        <div id="custom-error-output" class="output"></div>
    </div>

    <div class="example">
        <h3>3. Error Handling Patterns</h3>
        <p>Demonstrates common error handling patterns and strategies</p>
        <button onclick="runErrorPatternExamples()">Run Examples</button>
        <div id="error-pattern-output" class="output"></div>
    </div>

    <div class="example">
        <h3>4. Async Error Handling</h3>
        <p>Demonstrates error handling with promises and async/await</p>
        <button onclick="runAsyncErrorExamples()">Run Examples</button>
        <div id="async-error-output" class="output"></div>
    </div>

    <script>
        // Utility function to display output
        function displayOutput(elementId, content) {
            const element = document.getElementById(elementId);
            element.innerHTML = content;
        }

        // 1. Basic Error Handling Examples
        function runBasicErrorExamples() {
            let output = '';
            
            // Basic try-catch
            output += '=== Basic Try-Catch ===\n';
            try {
                let result = 10 / 0;
                if (!isFinite(result)) {
                    throw new Error('Division by zero results in infinity');
                }
                output += `Result: ${result}\n`;
            } catch (error) {
                output += `Error caught: ${error.message}\n`;
            }
            
            // Try-catch-finally
            output += '\n=== Try-Catch-Finally ===\n';
            let fileHandle = null;
            try {
                // Simulate file opening
                fileHandle = { name: 'test.txt', open: true };
                output += `File ${fileHandle.name} opened\n`;
                
                // Simulate file reading
                if (fileHandle.name === 'nonexistent.txt') {
                    throw new Error('File not found');
                }
                
                output += 'File content read successfully\n';
                
            } catch (error) {
                output += `Error reading file: ${error.message}\n`;
            } finally {
                // Always close file handle
                if (fileHandle) {
                    fileHandle.open = false;
                    output += `File ${fileHandle.name} closed\n`;
                }
            }
            
            // Different error types
            output += '\n=== Different Error Types ===\n';
            
            // ReferenceError
            try {
                console.log(undefinedVariable);
            } catch (error) {
                output += `ReferenceError: ${error.name}\n`;
            }
            
            // TypeError
            try {
                let num = 42;
                num.toUpperCase();
            } catch (error) {
                output += `TypeError: ${error.name}\n`;
            }
            
            // RangeError
            try {
                let arr = new Array(-1);
            } catch (error) {
                output += `RangeError: ${error.name}\n`;
            }
            
            // URIError
            try {
                decodeURIComponent('%');
            } catch (error) {
                output += `URIError: ${error.name}\n`;
            }
            
            // Custom error
            try {
                throw new Error('Custom error message');
            } catch (error) {
                output += `Custom Error: ${error.name} - ${error.message}\n`;
            }
            
            // Error object properties
            output += '\n=== Error Object Properties ===\n';
            try {
                throw new Error('Test error');
            } catch (error) {
                output += `Name: ${error.name}\n`;
                output += `Message: ${error.message}\n`;
                output += `Stack: ${error.stack}\n`;
                output += `ToString: ${error.toString()}\n`;
            }
            
            displayOutput('basic-error-output', output);
        }

        // 2. Custom Error Classes Examples
        function runCustomErrorExamples() {
            let output = '';
            
            // Basic custom error
            output += '=== Basic Custom Error ===\n';
            class ValidationError extends Error {
                constructor(message, field) {
                    super(message);
                    this.name = 'ValidationError';
                    this.field = field;
                }
            }
            
            class DatabaseError extends Error {
                constructor(message, code) {
                    super(message);
                    this.name = 'DatabaseError';
                    this.code = code;
                }
            }
            
            class APIError extends Error {
                constructor(message, statusCode, response) {
                    super(message);
                    this.name = 'APIError';
                    this.statusCode = statusCode;
                    this.response = response;
                    this.timestamp = new Date().toISOString();
                }
            }
            
            // Using custom errors
            try {
                throw new ValidationError('Name is required', 'name');
            } catch (error) {
                if (error instanceof ValidationError) {
                    output += `Validation failed for field '${error.field}': ${error.message}\n`;
                }
            }
            
            try {
                throw new DatabaseError('Connection failed', 'CONN_001');
            } catch (error) {
                if (error instanceof DatabaseError) {
                    output += `Database error ${error.code}: ${error.message}\n`;
                }
            }
            
            try {
                throw new APIError('Request failed', 404, 'Not Found');
            } catch (error) {
                if (error instanceof APIError) {
                    output += `API error ${error.statusCode}: ${error.message}\n`;
                    output += `Response: ${error.response}\n`;
                    output += `Timestamp: ${error.timestamp}\n`;
                }
            }
            
            // Error handling with custom errors
            output += '\n=== Error Handling with Custom Errors ===\n';
            function validateUser(user) {
                if (!user) {
                    throw new ValidationError('User object is required');
                }
                
                if (!user.name) {
                    throw new ValidationError('Name is required', 'name');
                }
                
                if (!user.email) {
                    throw new ValidationError('Email is required', 'email');
                }
                
                if (!user.email.includes('@')) {
                    throw new ValidationError('Invalid email format', 'email');
                }
                
                return true;
            }
            
            // Test validation
            try {
                validateUser({ name: 'John', email: 'john@example.com' });
                output += 'User validation passed\n';
            } catch (error) {
                if (error instanceof ValidationError) {
                    output += `Validation error: ${error.message}\n`;
                }
            }
            
            try {
                validateUser({ name: 'Jane', email: 'invalid-email' });
            } catch (error) {
                if (error instanceof ValidationError) {
                    output += `Validation error: ${error.message}\n`;
                }
            }
            
            try {
                validateUser(null);
            } catch (error) {
                if (error instanceof ValidationError) {
                    output += `Validation error: ${error.message}\n`;
                }
            }
            
            displayOutput('custom-error-output', output);
        }

        // 3. Error Handling Patterns Examples
        function runErrorPatternExamples() {
            let output = '';
            
            // Retry pattern
            output += '=== Retry Pattern ===\n';
            async function retryOperation(operation, maxRetries = 3, delay = 1000) {
                let lastError;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        return await operation();
                    } catch (error) {
                        lastError = error;
                        output += `Attempt ${attempt} failed: ${error.message}\n`;
                        
                        if (attempt < maxRetries) {
                            output += `Retrying in ${delay}ms...\n`;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2; // Exponential backoff
                        }
                    }
                }
                
                throw new Error(`Operation failed after ${maxRetries} attempts. Last error: ${lastError.message}`);
            }
            
            // Simulate a flaky operation
            let attemptCount = 0;
            async function flakyOperation() {
                attemptCount++;
                if (attemptCount < 3) {
                    throw new Error('Temporary failure');
                }
                return 'Success!';
            }
            
            try {
                let result = await retryOperation(flakyOperation, 3, 100);
                output += `Result: ${result}\n`;
            } catch (error) {
                output += `Final error: ${error.message}\n`;
            }
            
            // Circuit breaker pattern
            output += '\n=== Circuit Breaker Pattern ===\n';
            class CircuitBreaker {
                constructor(threshold = 5, timeout = 60000) {
                    this.threshold = threshold;
                    this.timeout = timeout;
                    this.failureCount = 0;
                    this.lastFailureTime = null;
                    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
                }
                
                async execute(operation) {
                    if (this.state === 'OPEN') {
                        if (Date.now() - this.lastFailureTime > this.timeout) {
                            this.state = 'HALF_OPEN';
                        } else {
                            throw new Error('Circuit breaker is OPEN');
                        }
                    }
                    
                    try {
                        const result = await operation();
                        this.onSuccess();
                        return result;
                    } catch (error) {
                        this.onFailure();
                        throw error;
                    }
                }
                
                onSuccess() {
                    this.failureCount = 0;
                    this.state = 'CLOSED';
                }
                
                onFailure() {
                    this.failureCount++;
                    this.lastFailureTime = Date.now();
                    
                    if (this.failureCount >= this.threshold) {
                        this.state = 'OPEN';
                    }
                }
            }
            
            let circuitBreaker = new CircuitBreaker(2, 5000);
            
            // Simulate failing operation
            async function failingOperation() {
                throw new Error('Operation failed');
            }
            
            try {
                await circuitBreaker.execute(failingOperation);
            } catch (error) {
                output += `First failure: ${error.message}\n`;
            }
            
            try {
                await circuitBreaker.execute(failingOperation);
            } catch (error) {
                output += `Second failure: ${error.message}\n`;
            }
            
            try {
                await circuitBreaker.execute(failingOperation);
            } catch (error) {
                output += `Third failure: ${error.message}\n`;
            }
            
            // Error boundary pattern
            output += '\n=== Error Boundary Pattern ===\n';
            class ErrorBoundary {
                constructor() {
                    this.error = null;
                    this.errorInfo = null;
                }
                
                componentDidCatch(error, errorInfo) {
                    this.error = error;
                    this.errorInfo = errorInfo;
                    output += `Error caught by boundary: ${error.message}\n`;
                }
                
                render() {
                    if (this.error) {
                        return `Error: ${this.error.message}`;
                    }
                    return null;
                }
            }
            
            let errorBoundary = new ErrorBoundary();
            try {
                // Simulate error
                throw new Error('Component error');
            } catch (error) {
                errorBoundary.componentDidCatch(error, { componentStack: 'App' });
            }
            
            // Global error handling
            output += '\n=== Global Error Handling ===\n';
            window.addEventListener('error', function(event) {
                output += `Global error: ${event.error.message}\n`;
            });
            
            window.addEventListener('unhandledrejection', function(event) {
                output += `Unhandled promise rejection: ${event.reason}\n`;
            });
            
            // Simulate global error
            setTimeout(() => {
                throw new Error('Global error');
            }, 100);
            
            // Simulate unhandled promise rejection
            setTimeout(() => {
                Promise.reject(new Error('Unhandled promise rejection'));
            }, 200);
            
            displayOutput('error-pattern-output', output);
        }

        // 4. Async Error Handling Examples
        function runAsyncErrorExamples() {
            let output = '';
            
            // Promise error handling
            output += '=== Promise Error Handling ===\n';
            function createPromise(success) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        if (success) {
                            resolve('Success!');
                        } else {
                            reject(new Error('Promise failed'));
                        }
                    }, 100);
                });
            }
            
            // Using .catch()
            createPromise(false)
                .then(result => {
                    output += `Result: ${result}\n`;
                })
                .catch(error => {
                    output += `Error: ${error.message}\n`;
                });
            
            // Using .finally()
            createPromise(true)
                .then(result => {
                    output += `Result: ${result}\n`;
                })
                .catch(error => {
                    output += `Error: ${error.message}\n`;
                })
                .finally(() => {
                    output += 'Promise completed\n';
                });
            
            // Promise chaining with error handling
            output += '\n=== Promise Chaining ===\n';
            function fetchData() {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve({ id: 1, name: 'John' });
                    }, 100);
                });
            }
            
            function processData(data) {
                return new Promise((resolve, reject) => {
                    if (!data.name) {
                        reject(new Error('Invalid data'));
                    } else {
                        resolve({ ...data, processed: true });
                    }
                });
            }
            
            function saveData(data) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve('Data saved');
                    }, 100);
                });
            }
            
            fetchData()
                .then(processData)
                .then(saveData)
                .then(result => {
                    output += `Final result: ${result}\n`;
                })
                .catch(error => {
                    output += `Error in chain: ${error.message}\n`;
                });
            
            // Async/await error handling
            output += '\n=== Async/Await Error Handling ===\n';
            async function asyncOperation() {
                try {
                    let data = await fetchData();
                    let processed = await processData(data);
                    let result = await saveData(processed);
                    output += `Async result: ${result}\n`;
                } catch (error) {
                    output += `Async error: ${error.message}\n`;
                }
            }
            
            asyncOperation();
            
            // Multiple async operations
            output += '\n=== Multiple Async Operations ===\n';
            async function multipleOperations() {
                try {
                    let [data1, data2] = await Promise.all([
                        fetchData(),
                        fetchData()
                    ]);
                    output += `Data1: ${data1.name}, Data2: ${data2.name}\n`;
                } catch (error) {
                    output += `Multiple operations error: ${error.message}\n`;
                }
            }
            
            multipleOperations();
            
            // Async error handling with custom errors
            output += '\n=== Async with Custom Errors ===\n';
            async function fetchUserData(userId) {
                try {
                    // Simulate API call
                    if (userId < 1) {
                        throw new APIError('Invalid user ID', 400, 'Bad Request');
                    }
                    
                    if (userId === 404) {
                        throw new APIError('User not found', 404, 'Not Found');
                    }
                    
                    return { id: userId, name: 'John Doe' };
                } catch (error) {
                    if (error instanceof APIError) {
                        throw error;
                    } else {
                        throw new APIError('Network error', 500, 'Internal Server Error');
                    }
                }
            }
            
            async function handleUserData(userId) {
                try {
                    let userData = await fetchUserData(userId);
                    output += `User data: ${JSON.stringify(userData)}\n`;
                } catch (error) {
                    if (error instanceof APIError) {
                        output += `API Error ${error.statusCode}: ${error.message}\n`;
                    } else {
                        output += `Unexpected error: ${error.message}\n`;
                    }
                }
            }
            
            // Test different scenarios
            handleUserData(1);
            handleUserData(0);
            handleUserData(404);
            
            displayOutput('async-error-output', output);
        }
    </script>
</body>
</html>

