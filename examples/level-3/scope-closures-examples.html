<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scope & Closures Examples - Level 3</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1, h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .example {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .example h3 {
            color: #495057;
            margin-top: 0;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
        }
        .output {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #2980b9;
        }
        .scope-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .scope-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }
        .scope-card h4 {
            color: #2c3e50;
            margin-top: 0;
        }
        .warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            color: #856404;
        }
        .success {
            background: #d4edda;
            border: 2px solid #28a745;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            color: #155724;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Scope & Closures Examples</h1>
        <p>This page demonstrates JavaScript scope chain, lexical scoping, closures, and memory management concepts.</p>

        <div class="scope-types">
            <div class="scope-card">
                <h4>Scope Types</h4>
                <p>Global, function, and block scope examples</p>
                <button onclick="demoScopeTypes()">Run Example</button>
            </div>
            <div class="scope-card">
                <h4>Scope Chain</h4>
                <p>How JavaScript looks up variables</p>
                <button onclick="demoScopeChain()">Run Example</button>
            </div>
            <div class="scope-card">
                <h4>Closures</h4>
                <p>Functions that remember their outer scope</p>
                <button onclick="demoClosures()">Run Example</button>
            </div>
            <div class="scope-card">
                <h4>Memory Management</h4>
                <p>Closure memory leaks and optimization</p>
                <button onclick="demoMemoryManagement()">Run Example</button>
            </div>
            <div class="scope-card">
                <h4>Common Pitfalls</h4>
                <p>Scope-related mistakes and solutions</p>
                <button onclick="demoCommonPitfalls()">Run Example</button>
            </div>
            <div class="scope-card">
                <h4>Practical Applications</h4>
                <p>Real-world closure patterns</p>
                <button onclick="demoPracticalApplications()">Run Example</button>
            </div>
        </div>

        <div id="output" class="output" style="display: none;"></div>
    </div>

    <script>
        // Scope Types
        function demoScopeTypes() {
            const output = document.getElementById('output');
            output.style.display = 'block';
            
            // Global scope
            var globalVar = "I'm global";
            let globalLet = "I'm also global";
            const globalConst = "I'm global too";
            
            function functionScope() {
                // Function scope
                var functionVar = "I'm in function scope";
                let functionLet = "I'm also in function scope";
                const functionConst = "I'm in function scope too";
                
                console.log("Function scope variables:", functionVar, functionLet, functionConst);
                
                if (true) {
                    // Block scope
                    var varInBlock = "I'm accessible outside block";
                    let letInBlock = "I'm only accessible inside block";
                    const constInBlock = "I'm only accessible inside block";
                    
                    console.log("Block scope variables:", varInBlock, letInBlock, constInBlock);
                }
                
                // console.log(letInBlock); // ReferenceError
                // console.log(constInBlock); // ReferenceError
                console.log("varInBlock is accessible:", varInBlock);
            }
            
            functionScope();
            
            output.textContent = `Scope Types Demo:

Global Scope:
- globalVar: ${globalVar}
- globalLet: ${globalLet}
- globalConst: ${globalConst}

Function Scope:
- Variables declared inside functions are only accessible within that function
- var has function scope, let and const have block scope

Block Scope:
- let and const are only accessible within their block
- var is accessible outside the block

Check console for detailed output.`;
        }

        // Scope Chain
        function demoScopeChain() {
            const output = document.getElementById('output');
            output.style.display = 'block';
            
            // Global scope
            var globalVar = "global";
            
            function outerFunction() {
                // Outer function scope
                var outerVar = "outer";
                
                function innerFunction() {
                    // Inner function scope
                    var innerVar = "inner";
                    
                    // JavaScript looks for variables in this order:
                    // 1. Inner function scope (innerVar)
                    // 2. Outer function scope (outerVar)
                    // 3. Global scope (globalVar)
                    console.log("Inner function variables:", innerVar, outerVar, globalVar);
                    
                    // Variable shadowing
                    var outerVar = "shadowed outer";
                    console.log("Shadowed outerVar:", outerVar);
                }
                
                innerFunction();
                console.log("Outer function variables:", outerVar, globalVar);
            }
            
            outerFunction();
            console.log("Global variables:", globalVar);
            
            output.textContent = `Scope Chain Demo:

Scope Chain Order:
1. Inner function scope
2. Outer function scope  
3. Global scope

Variable Shadowing:
- Inner variables can shadow outer variables
- JavaScript looks up the scope chain from inner to outer

Check console for detailed output showing scope chain traversal.`;
        }

        // Closures
        function demoClosures() {
            const output = document.getElementById('output');
            output.style.display = 'block';
            
            // Basic closure
            function outerFunction(x) {
                const outerVariable = x;
                
                function innerFunction(y) {
                    return outerVariable + y;
                }
                
                return innerFunction;
            }
            
            const closure = outerFunction(10);
            const result = closure(5);
            
            // Closure with multiple variables
            function createCounter(initialValue = 0) {
                let count = initialValue;
                
                return {
                    increment: function() {
                        return ++count;
                    },
                    decrement: function() {
                        return --count;
                    },
                    getValue: function() {
                        return count;
                    },
                    reset: function() {
                        count = initialValue;
                    }
                };
            }
            
            const counter = createCounter(10);
            const incrementResult = counter.increment();
            const decrementResult = counter.decrement();
            const currentValue = counter.getValue();
            
            // Module pattern with closure
            const UserModule = (function() {
                let users = [];
                let nextId = 1;
                
                function generateId() {
                    return nextId++;
                }
                
                function validateUser(user) {
                    return user.name && user.email;
                }
                
                return {
                    addUser: function(user) {
                        if (validateUser(user)) {
                            user.id = generateId();
                            users.push(user);
                            return user;
                        }
                        throw new Error("Invalid user data");
                    },
                    getAllUsers: function() {
                        return [...users];
                    },
                    getUserCount: function() {
                        return users.length;
                    }
                };
            })();
            
            UserModule.addUser({ name: "John", email: "john@example.com" });
            UserModule.addUser({ name: "Jane", email: "jane@example.com" });
            const users = UserModule.getAllUsers();
            const userCount = UserModule.getUserCount();
            
            output.textContent = `Closures Demo:

Basic Closure:
- outerFunction(10) returns innerFunction
- innerFunction(5) = ${result}

Counter Closure:
- Initial value: 10
- After increment: ${incrementResult}
- After decrement: ${decrementResult}
- Current value: ${currentValue}

Module Pattern:
- Users added: ${userCount}
- User data: ${JSON.stringify(users, null, 2)}

Closures allow functions to "remember" their outer scope even after the outer function returns.`;
        }

        // Memory Management
        function demoMemoryManagement() {
            const output = document.getElementById('output');
            output.style.display = 'block';
            
            // Memory leak example
            function createMemoryLeak() {
                const largeArray = new Array(1000000).fill('data');
                
                return function() {
                    console.log('Closure created');
                    // This closure keeps a reference to largeArray
                    // even if we don't use it
                };
            }
            
            // Optimized version
            function createOptimizedClosure() {
                const largeArray = new Array(1000000).fill('data');
                const summary = largeArray.length; // Extract only what you need
                
                return function() {
                    console.log(`Array has ${summary} elements`);
                    // No reference to largeArray
                };
            }
            
            // Garbage collection example
            function createCleanClosure() {
                const data = { value: 42 };
                
                function closureFunction() {
                    console.log(data.value);
                }
                
                // Provide cleanup method
                closureFunction.cleanup = function() {
                    Object.keys(data).forEach(key => delete data[key]);
                };
                
                return closureFunction;
            }
            
            const leakyClosure = createMemoryLeak();
            const optimizedClosure = createOptimizedClosure();
            const cleanClosure = createCleanClosure();
            
            // Test closures
            leakyClosure();
            optimizedClosure();
            cleanClosure();
            
            // Clean up
            cleanClosure.cleanup();
            
            output.textContent = `Memory Management Demo:

Memory Leak Example:
- Closure holds reference to large array
- Array cannot be garbage collected
- Memory usage remains high

Optimized Version:
- Only keeps necessary data
- Large array can be garbage collected
- Memory usage is lower

Clean Closure:
- Provides cleanup method
- Explicitly nullifies references
- Helps garbage collection

Best Practices:
1. Only keep what you need in closures
2. Provide cleanup methods when possible
3. Be mindful of circular references
4. Use WeakMap for private data when appropriate`;
        }

        // Common Pitfalls
        function demoCommonPitfalls() {
            const output = document.getElementById('output');
            output.style.display = 'block';
            
            // Loop variable scope issue
            function createFunctions() {
                const functions = [];
                
                for (var i = 0; i < 3; i++) {
                    functions.push(function() {
                        return i; // All functions will return 3
                    });
                }
                
                return functions;
            }
            
            const funcs = createFunctions();
            const results = funcs.map(fn => fn());
            
            // Solution 1: Use let
            function createFunctionsWithLet() {
                const functions = [];
                
                for (let i = 0; i < 3; i++) {
                    functions.push(function() {
                        return i; // Each function returns its own i
                    });
                }
                
                return functions;
            }
            
            const funcsWithLet = createFunctionsWithLet();
            const resultsWithLet = funcsWithLet.map(fn => fn());
            
            // Solution 2: Use IIFE with var
            function createFunctionsWithIIFE() {
                const functions = [];
                
                for (var i = 0; i < 3; i++) {
                    (function(j) {
                        functions.push(function() {
                            return j; // Each function returns its own j
                        });
                    })(i);
                }
                
                return functions;
            }
            
            const funcsWithIIFE = createFunctionsWithIIFE();
            const resultsWithIIFE = funcsWithIIFE.map(fn => fn());
            
            output.textContent = `Common Pitfalls Demo:

Loop Variable Scope Issue:
- Using var in loop: [${results.join(', ')}]
- All functions return 3 (final value of i)

Solution 1 - Use let:
- Using let in loop: [${resultsWithLet.join(', ')}]
- Each function returns its own i value

Solution 2 - Use IIFE:
- Using IIFE with var: [${resultsWithIIFE.join(', ')}]
- Each function returns its own j value

Key Points:
1. var has function scope, let has block scope
2. Closures capture variables by reference, not value
3. Use let or IIFE to create new scope for each iteration
4. Be careful with async operations in loops`;
        }

        // Practical Applications
        function demoPracticalApplications() {
            const output = document.getElementById('output');
            output.style.display = 'block';
            
            // Data privacy
            function createPrivateData() {
                let privateData = {
                    secret: "This is private",
                    count: 0
                };
                
                return {
                    getSecret: function() {
                        return privateData.secret;
                    },
                    incrementCount: function() {
                        privateData.count++;
                        return privateData.count;
                    },
                    getCount: function() {
                        return privateData.count;
                    }
                };
            }
            
            const data = createPrivateData();
            const secret = data.getSecret();
            const count1 = data.incrementCount();
            const count2 = data.incrementCount();
            const currentCount = data.getCount();
            
            // Function memoization
            function memoize(fn) {
                const cache = new Map();
                
                return function(...args) {
                    const key = JSON.stringify(args);
                    
                    if (cache.has(key)) {
                        console.log('Cache hit');
                        return cache.get(key);
                    }
                    
                    console.log('Cache miss');
                    const result = fn(...args);
                    cache.set(key, result);
                    return result;
                };
            }
            
            function expensiveCalculation(n) {
                console.log(`Calculating for ${n}`);
                return n * n * n;
            }
            
            const memoizedCalculation = memoize(expensiveCalculation);
            const result1 = memoizedCalculation(5);
            const result2 = memoizedCalculation(5);
            
            // Partial application
            function partial(fn, ...args) {
                return function(...remainingArgs) {
                    return fn(...args, ...remainingArgs);
                };
            }
            
            function add(a, b, c) {
                return a + b + c;
            }
            
            const add5 = partial(add, 5);
            const add5And10 = partial(add, 5, 10);
            const sum1 = add5(3, 2);
            const sum2 = add5And10(1);
            
            output.textContent = `Practical Applications Demo:

Data Privacy:
- Secret: ${secret}
- Count after increment: ${count1}
- Count after increment: ${count2}
- Current count: ${currentCount}
- Private data is not directly accessible

Function Memoization:
- First call: ${result1} (calculated)
- Second call: ${result2} (cached)
- Prevents recalculation of expensive operations

Partial Application:
- add5(3, 2) = ${sum1}
- add5And10(1) = ${sum2}
- Creates specialized functions from general ones

Closures enable powerful patterns for:
1. Data privacy and encapsulation
2. Function memoization and caching
3. Partial application and currying
4. Module patterns and namespaces
5. Event handling and callbacks`;
        }
    </script>
</body>
</html>


