<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async/Await Examples - Level 4</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 40px;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #fafafa;
        }
        
        .section h2 {
            color: #333;
            margin-top: 0;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .demo-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .demo-button:active {
            transform: translateY(0);
        }
        
        .result {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .success {
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .card h3 {
            margin-top: 0;
            color: #2d3748;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
        }
        
        .comparison-item h4 {
            margin-top: 0;
            color: #2d3748;
        }
        
        .highlight {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .tip {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Async/Await Examples</h1>
            <p>Level 4 - Frontend Mastery Hub</p>
        </div>
        
        <div class="content">
            <!-- Basic Async/Await Section -->
            <div class="section">
                <h2>1. Basic Async/Await</h2>
                <p>Understanding the fundamental concepts of async/await syntax.</p>
                
                <div class="code-block">
// Basic async/await example
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching data:', error);
        throw error;
    }
}

// Using the async function
fetchData()
    .then(data => console.log('Data:', data))
    .catch(error => console.error('Error:', error));
                </div>
                
                <button class="demo-button" onclick="demoBasicAsyncAwait()">Demo Basic Async/Await</button>
                <div id="basic-result" class="result"></div>
            </div>
            
            <!-- Async Function Declaration Section -->
            <div class="section">
                <h2>2. Async Function Declarations</h2>
                <p>Different ways to declare and use async functions.</p>
                
                <div class="code-block">
// Async function declaration
async function getUser(id) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
}

// Async arrow function
const getPost = async (id) => {
    const response = await fetch(`/api/posts/${id}`);
    return response.json();
};

// Async method in class
class ApiService {
    async fetchData(url) {
        const response = await fetch(url);
        return response.json();
    }
}

// Immediately invoked async function
(async () => {
    try {
        const user = await getUser(1);
        console.log('User:', user);
    } catch (error) {
        console.error('Error:', error);
    }
})();
                </div>
                
                <button class="demo-button" onclick="demoAsyncDeclarations()">Demo Async Declarations</button>
                <div id="declarations-result" class="result"></div>
            </div>
            
            <!-- Error Handling Section -->
            <div class="section">
                <h2>3. Error Handling with Async/Await</h2>
                <p>Proper error handling in async/await functions using try/catch blocks.</p>
                
                <div class="code-block">
// Error handling with async/await
async function fetchUserData(userId) {
    try {
        const userResponse = await fetch(`/api/users/${userId}`);
        
        if (!userResponse.ok) {
            throw new Error(`HTTP error! status: ${userResponse.status}`);
        }
        
        const user = await userResponse.json();
        
        // Fetch additional data
        const postsResponse = await fetch(`/api/users/${userId}/posts`);
        const posts = await postsResponse.json();
        
        return { user, posts };
    } catch (error) {
        console.error('Error fetching user data:', error);
        throw error; // Re-throw to let caller handle
    }
}

// Using the function with error handling
fetchUserData(1)
    .then(data => console.log('User data:', data))
    .catch(error => console.error('Failed to fetch user data:', error));
                </div>
                
                <button class="demo-button" onclick="demoErrorHandling()">Demo Error Handling</button>
                <div id="error-result" class="result"></div>
            </div>
            
            <!-- Sequential vs Parallel Section -->
            <div class="section">
                <h2>4. Sequential vs Parallel Execution</h2>
                <p>Understanding when to use sequential vs parallel async operations.</p>
                
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>Sequential Execution</h4>
                        <div class="code-block">
// Sequential - each waits for the previous
async function sequentialFetch() {
    const user = await fetchUser(1);
    const posts = await fetchUserPosts(user.id);
    const comments = await fetchPostComments(posts[0].id);
    
    return { user, posts, comments };
}
                        </div>
                        <div class="highlight">
                            <strong>Use when:</strong> Each operation depends on the result of the previous one.
                        </div>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>Parallel Execution</h4>
                        <div class="code-block">
// Parallel - all execute simultaneously
async function parallelFetch() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(1),
        fetchUserPosts(1),
        fetchPostComments(1)
    ]);
    
    return { user, posts, comments };
}
                        </div>
                        <div class="highlight">
                            <strong>Use when:</strong> Operations are independent and can run simultaneously.
                        </div>
                    </div>
                </div>
                
                <button class="demo-button" onclick="demoSequentialVsParallel()">Demo Sequential vs Parallel</button>
                <div id="sequential-parallel-result" class="result"></div>
            </div>
            
            <!-- Promise.all with Async/Await Section -->
            <div class="section">
                <h2>5. Promise.all with Async/Await</h2>
                <p>Using Promise.all to execute multiple async operations in parallel.</p>
                
                <div class="code-block">
// Promise.all with async/await
async function fetchMultipleData() {
    try {
        const [users, posts, comments] = await Promise.all([
            fetch('/api/users').then(res => res.json()),
            fetch('/api/posts').then(res => res.json()),
            fetch('/api/comments').then(res => res.json())
        ]);
        
        return { users, posts, comments };
    } catch (error) {
        console.error('Error fetching multiple data:', error);
        throw error;
    }
}

// Using Promise.allSettled for partial success
async function fetchDataWithPartialSuccess() {
    const results = await Promise.allSettled([
        fetch('/api/users').then(res => res.json()),
        fetch('/api/posts').then(res => res.json()),
        fetch('/api/comments').then(res => res.json())
    ]);
    
    const successful = results
        .filter(result => result.status === 'fulfilled')
        .map(result => result.value);
    
    const failed = results
        .filter(result => result.status === 'rejected')
        .map(result => result.reason);
    
    return { successful, failed };
}
                </div>
                
                <button class="demo-button" onclick="demoPromiseAll()">Demo Promise.all</button>
                <div id="promise-all-result" class="result"></div>
            </div>
            
            <!-- Async Iteration Section -->
            <div class="section">
                <h2>6. Async Iteration</h2>
                <p>Using async/await with loops and iteration.</p>
                
                <div class="code-block">
// Async iteration with for...of
async function processUsers(userIds) {
    const results = [];
    
    for (const userId of userIds) {
        try {
            const user = await fetchUser(userId);
            results.push(user);
        } catch (error) {
            console.error(`Failed to fetch user ${userId}:`, error);
            results.push({ id: userId, error: error.message });
        }
    }
    
    return results;
}

// Async iteration with map (parallel)
async function processUsersParallel(userIds) {
    const promises = userIds.map(async (userId) => {
        try {
            return await fetchUser(userId);
        } catch (error) {
            return { id: userId, error: error.message };
        }
    });
    
    return await Promise.all(promises);
}

// Async iteration with reduce
async function processUsersSequential(userIds) {
    return await userIds.reduce(async (acc, userId) => {
        const results = await acc;
        try {
            const user = await fetchUser(userId);
            results.push(user);
        } catch (error) {
            results.push({ id: userId, error: error.message });
        }
        return results;
    }, Promise.resolve([]));
}
                </div>
                
                <button class="demo-button" onclick="demoAsyncIteration()">Demo Async Iteration</button>
                <div id="iteration-result" class="result"></div>
            </div>
            
            <!-- Real-world Example Section -->
            <div class="section">
                <h2>7. Real-world Example: Weather Dashboard</h2>
                <p>A practical example of async/await in a weather dashboard application.</p>
                
                <div class="code-block">
// Weather dashboard example
class WeatherService {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseURL = 'https://api.openweathermap.org/data/2.5';
    }
    
    async getCurrentWeather(city) {
        try {
            const response = await fetch(
                `${this.baseURL}/weather?q=${city}&appid=${this.apiKey}&units=metric`
            );
            
            if (!response.ok) {
                throw new Error(`Weather API error: ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error fetching weather:', error);
            throw error;
        }
    }
    
    async getForecast(city) {
        try {
            const response = await fetch(
                `${this.baseURL}/forecast?q=${city}&appid=${this.apiKey}&units=metric`
            );
            
            if (!response.ok) {
                throw new Error(`Forecast API error: ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('Error fetching forecast:', error);
            throw error;
        }
    }
    
    async getWeatherData(city) {
        try {
            const [currentWeather, forecast] = await Promise.all([
                this.getCurrentWeather(city),
                this.getForecast(city)
            ]);
            
            return {
                current: currentWeather,
                forecast: forecast,
                city: city
            };
        } catch (error) {
            console.error('Error fetching weather data:', error);
            throw error;
        }
    }
}

// Using the weather service
const weatherService = new WeatherService('your-api-key');

weatherService.getWeatherData('London')
    .then(data => console.log('Weather data:', data))
    .catch(error => console.error('Failed to get weather:', error));
                </div>
                
                <button class="demo-button" onclick="demoWeatherDashboard()">Demo Weather Dashboard</button>
                <div id="weather-result" class="result"></div>
            </div>
            
            <!-- Advanced Patterns Section -->
            <div class="section">
                <h2>8. Advanced Async/Await Patterns</h2>
                <p>Advanced patterns and techniques for working with async/await.</p>
                
                <div class="code-block">
// Retry pattern with async/await
async function retryAsync(fn, maxRetries = 3, delay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
        }
    }
}

// Timeout pattern
async function withTimeout(promise, timeoutMs) {
    const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeoutMs)
    );
    
    return Promise.race([promise, timeoutPromise]);
}

// Batch processing
async function processBatch(items, batchSize, processor) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        const batchPromises = batch.map(processor);
        const batchResults = await Promise.allSettled(batchPromises);
        results.push(...batchResults);
    }
    
    return results;
}

// Circuit breaker pattern
class CircuitBreaker {
    constructor(threshold = 5, timeout = 60000) {
        this.threshold = threshold;
        this.timeout = timeout;
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    }
    
    async execute(fn) {
        if (this.state === 'OPEN') {
            if (Date.now() - this.lastFailureTime > this.timeout) {
                this.state = 'HALF_OPEN';
            } else {
                throw new Error('Circuit breaker is OPEN');
            }
        }
        
        try {
            const result = await fn();
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }
    
    onSuccess() {
        this.failureCount = 0;
        this.state = 'CLOSED';
    }
    
    onFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        
        if (this.failureCount >= this.threshold) {
            this.state = 'OPEN';
        }
    }
}
                </div>
                
                <button class="demo-button" onclick="demoAdvancedPatterns()">Demo Advanced Patterns</button>
                <div id="advanced-result" class="result"></div>
            </div>
            
            <!-- Best Practices Section -->
            <div class="section">
                <h2>9. Best Practices</h2>
                <p>Best practices and common pitfalls when using async/await.</p>
                
                <div class="grid">
                    <div class="card">
                        <h3>✅ Do's</h3>
                        <ul>
                            <li>Always use try/catch for error handling</li>
                            <li>Use Promise.all() for parallel operations</li>
                            <li>Handle errors at the appropriate level</li>
                            <li>Use async/await consistently</li>
                            <li>Consider using Promise.allSettled() for partial success</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h3>❌ Don'ts</h3>
                        <ul>
                            <li>Don't forget to await async functions</li>
                            <li>Don't use async/await in forEach loops</li>
                            <li>Don't mix async/await with .then() unnecessarily</li>
                            <li>Don't ignore promise rejections</li>
                            <li>Don't use async/await for synchronous operations</li>
                        </ul>
                    </div>
                </div>
                
                <div class="tip">
                    <strong>💡 Tip:</strong> Use async/await for cleaner, more readable code, but remember that it's just syntactic sugar over Promises. The underlying behavior is the same.
                </div>
                
                <div class="warning">
                    <strong>⚠️ Warning:</strong> Be careful with error handling in async/await. Unhandled promise rejections can crash your application. Always use try/catch or .catch() to handle errors.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Utility function to display results
        function displayResult(elementId, content, type = 'info') {
            const element = document.getElementById(elementId);
            element.textContent = content;
            element.className = `result ${type}`;
        }
        
        // Basic async/await demo
        async function demoBasicAsyncAwait() {
            displayResult('basic-result', 'Loading...', 'info');
            
            async function fetchData() {
                try {
                    // Simulate API call
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const success = Math.random() > 0.3;
                    
                    if (success) {
                        return { message: "Data fetched successfully!", timestamp: new Date().toLocaleTimeString() };
                    } else {
                        throw new Error("API request failed");
                    }
                } catch (error) {
                    console.error('Error fetching data:', error);
                    throw error;
                }
            }
            
            try {
                const data = await fetchData();
                displayResult('basic-result', `Success: ${JSON.stringify(data, null, 2)}`, 'success');
            } catch (error) {
                displayResult('basic-result', `Error: ${error.message}`, 'error');
            }
        }
        
        // Async declarations demo
        async function demoAsyncDeclarations() {
            displayResult('declarations-result', 'Loading...', 'info');
            
            // Async function declaration
            async function getUser(id) {
                await new Promise(resolve => setTimeout(resolve, 500));
                return { id, name: `User ${id}`, email: `user${id}@example.com` };
            }
            
            // Async arrow function
            const getPost = async (id) => {
                await new Promise(resolve => setTimeout(resolve, 300));
                return { id, title: `Post ${id}`, content: `Content for post ${id}` };
            };
            
            // Async method in class
            class ApiService {
                async fetchData(url) {
                    await new Promise(resolve => setTimeout(resolve, 400));
                    return { url, data: `Data from ${url}` };
                }
            }
            
            let result = "Testing different async function declarations:\n\n";
            
            try {
                // Test async function declaration
                const user = await getUser(1);
                result += `1. Async function declaration: ${JSON.stringify(user, null, 2)}\n\n`;
                
                // Test async arrow function
                const post = await getPost(1);
                result += `2. Async arrow function: ${JSON.stringify(post, null, 2)}\n\n`;
                
                // Test async method in class
                const apiService = new ApiService();
                const data = await apiService.fetchData('/api/test');
                result += `3. Async method in class: ${JSON.stringify(data, null, 2)}\n\n`;
                
                result += "All async function types work correctly!";
                displayResult('declarations-result', result, 'success');
            } catch (error) {
                displayResult('declarations-result', `Error: ${error.message}`, 'error');
            }
        }
        
        // Error handling demo
        async function demoErrorHandling() {
            displayResult('error-result', 'Loading...', 'info');
            
            async function fetchUserData(userId) {
                try {
                    // Simulate API calls
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const success = Math.random() > 0.3;
                    if (!success) {
                        throw new Error(`HTTP error! status: 404`);
                    }
                    
                    const user = { id: userId, name: `User ${userId}` };
                    
                    // Fetch additional data
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const posts = [{ id: 1, title: `Post by User ${userId}` }];
                    
                    return { user, posts };
                } catch (error) {
                    console.error('Error fetching user data:', error);
                    throw error;
                }
            }
            
            try {
                const data = await fetchUserData(1);
                displayResult('error-result', `User data: ${JSON.stringify(data, null, 2)}`, 'success');
            } catch (error) {
                displayResult('error-result', `Failed to fetch user data: ${error.message}`, 'error');
            }
        }
        
        // Sequential vs parallel demo
        async function demoSequentialVsParallel() {
            displayResult('sequential-parallel-result', 'Loading...', 'info');
            
            async function fetchUser(id) {
                await new Promise(resolve => setTimeout(resolve, 500));
                return { id, name: `User ${id}` };
            }
            
            async function fetchUserPosts(userId) {
                await new Promise(resolve => setTimeout(resolve, 300));
                return [{ id: 1, title: `Post by User ${userId}` }];
            }
            
            async function fetchPostComments(postId) {
                await new Promise(resolve => setTimeout(resolve, 200));
                return [{ id: 1, text: `Comment on Post ${postId}` }];
            }
            
            let result = "Comparing sequential vs parallel execution:\n\n";
            
            // Sequential execution
            const startSequential = performance.now();
            try {
                const user = await fetchUser(1);
                const posts = await fetchUserPosts(user.id);
                const comments = await fetchPostComments(posts[0].id);
                const sequentialTime = performance.now() - startSequential;
                
                result += `Sequential execution (${sequentialTime.toFixed(2)}ms):\n`;
                result += `User: ${JSON.stringify(user)}\n`;
                result += `Posts: ${JSON.stringify(posts)}\n`;
                result += `Comments: ${JSON.stringify(comments)}\n\n`;
            } catch (error) {
                result += `Sequential execution failed: ${error.message}\n\n`;
            }
            
            // Parallel execution
            const startParallel = performance.now();
            try {
                const [user, posts, comments] = await Promise.all([
                    fetchUser(1),
                    fetchUserPosts(1),
                    fetchPostComments(1)
                ]);
                const parallelTime = performance.now() - startParallel;
                
                result += `Parallel execution (${parallelTime.toFixed(2)}ms):\n`;
                result += `User: ${JSON.stringify(user)}\n`;
                result += `Posts: ${JSON.stringify(posts)}\n`;
                result += `Comments: ${JSON.stringify(comments)}\n\n`;
                
                result += `Parallel execution was ${(sequentialTime / parallelTime).toFixed(2)}x faster!`;
                displayResult('sequential-parallel-result', result, 'success');
            } catch (error) {
                displayResult('sequential-parallel-result', `Parallel execution failed: ${error.message}`, 'error');
            }
        }
        
        // Promise.all demo
        async function demoPromiseAll() {
            displayResult('promise-all-result', 'Loading...', 'info');
            
            async function fetchData(url) {
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                const success = Math.random() > 0.2;
                if (success) {
                    return { url, data: `Data from ${url}` };
                } else {
                    throw new Error(`Failed to fetch from ${url}`);
                }
            }
            
            try {
                const [users, posts, comments] = await Promise.all([
                    fetchData('/api/users'),
                    fetchData('/api/posts'),
                    fetchData('/api/comments')
                ]);
                
                displayResult('promise-all-result', 
                    `All data fetched successfully:\n${JSON.stringify({ users, posts, comments }, null, 2)}`, 'success');
            } catch (error) {
                displayResult('promise-all-result', `One or more requests failed: ${error.message}`, 'error');
            }
        }
        
        // Async iteration demo
        async function demoAsyncIteration() {
            displayResult('iteration-result', 'Loading...', 'info');
            
            async function fetchUser(userId) {
                await new Promise(resolve => setTimeout(resolve, 500));
                const success = Math.random() > 0.3;
                if (success) {
                    return { id: userId, name: `User ${userId}` };
                } else {
                    throw new Error(`Failed to fetch user ${userId}`);
                }
            }
            
            const userIds = [1, 2, 3, 4, 5];
            let result = "Testing async iteration patterns:\n\n";
            
            // Sequential processing
            result += "1. Sequential processing:\n";
            const startSequential = performance.now();
            const sequentialResults = [];
            
            for (const userId of userIds) {
                try {
                    const user = await fetchUser(userId);
                    sequentialResults.push(user);
                } catch (error) {
                    sequentialResults.push({ id: userId, error: error.message });
                }
            }
            
            const sequentialTime = performance.now() - startSequential;
            result += `Time: ${sequentialTime.toFixed(2)}ms\n`;
            result += `Results: ${JSON.stringify(sequentialResults, null, 2)}\n\n`;
            
            // Parallel processing
            result += "2. Parallel processing:\n";
            const startParallel = performance.now();
            
            const promises = userIds.map(async (userId) => {
                try {
                    return await fetchUser(userId);
                } catch (error) {
                    return { id: userId, error: error.message };
                }
            });
            
            const parallelResults = await Promise.all(promises);
            const parallelTime = performance.now() - startParallel;
            
            result += `Time: ${parallelTime.toFixed(2)}ms\n`;
            result += `Results: ${JSON.stringify(parallelResults, null, 2)}\n\n`;
            
            result += `Parallel processing was ${(sequentialTime / parallelTime).toFixed(2)}x faster!`;
            displayResult('iteration-result', result, 'success');
        }
        
        // Weather dashboard demo
        async function demoWeatherDashboard() {
            displayResult('weather-result', 'Loading...', 'info');
            
            class WeatherService {
                constructor(apiKey) {
                    this.apiKey = apiKey;
                    this.baseURL = 'https://api.openweathermap.org/data/2.5';
                }
                
                async getCurrentWeather(city) {
                    try {
                        // Simulate API call
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        const success = Math.random() > 0.2;
                        
                        if (!success) {
                            throw new Error(`Weather API error: 404`);
                        }
                        
                        return {
                            name: city,
                            main: {
                                temp: Math.floor(Math.random() * 30) + 10,
                                humidity: Math.floor(Math.random() * 40) + 40
                            },
                            weather: [{
                                description: "Partly cloudy",
                                icon: "02d"
                            }]
                        };
                    } catch (error) {
                        console.error('Error fetching weather:', error);
                        throw error;
                    }
                }
                
                async getForecast(city) {
                    try {
                        // Simulate API call
                        await new Promise(resolve => setTimeout(resolve, 800));
                        const success = Math.random() > 0.2;
                        
                        if (!success) {
                            throw new Error(`Forecast API error: 404`);
                        }
                        
                        return {
                            list: [
                                { dt: Date.now() / 1000, main: { temp: 20 }, weather: [{ description: "Sunny" }] },
                                { dt: Date.now() / 1000 + 86400, main: { temp: 22 }, weather: [{ description: "Cloudy" }] }
                            ]
                        };
                    } catch (error) {
                        console.error('Error fetching forecast:', error);
                        throw error;
                    }
                }
                
                async getWeatherData(city) {
                    try {
                        const [currentWeather, forecast] = await Promise.all([
                            this.getCurrentWeather(city),
                            this.getForecast(city)
                        ]);
                        
                        return {
                            current: currentWeather,
                            forecast: forecast,
                            city: city
                        };
                    } catch (error) {
                        console.error('Error fetching weather data:', error);
                        throw error;
                    }
                }
            }
            
            try {
                const weatherService = new WeatherService('your-api-key');
                const data = await weatherService.getWeatherData('London');
                displayResult('weather-result', 
                    `Weather data for ${data.city}:\n${JSON.stringify(data, null, 2)}`, 'success');
            } catch (error) {
                displayResult('weather-result', `Failed to get weather: ${error.message}`, 'error');
            }
        }
        
        // Advanced patterns demo
        async function demoAdvancedPatterns() {
            displayResult('advanced-result', 'Loading...', 'info');
            
            // Retry pattern
            async function retryAsync(fn, maxRetries = 3, delay = 1000) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await fn();
                    } catch (error) {
                        if (i === maxRetries - 1) throw error;
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    }
                }
            }
            
            // Timeout pattern
            async function withTimeout(promise, timeoutMs) {
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), timeoutMs)
                );
                
                return Promise.race([promise, timeoutPromise]);
            }
            
            // Circuit breaker pattern
            class CircuitBreaker {
                constructor(threshold = 5, timeout = 60000) {
                    this.threshold = threshold;
                    this.timeout = timeout;
                    this.failureCount = 0;
                    this.lastFailureTime = null;
                    this.state = 'CLOSED';
                }
                
                async execute(fn) {
                    if (this.state === 'OPEN') {
                        if (Date.now() - this.lastFailureTime > this.timeout) {
                            this.state = 'HALF_OPEN';
                        } else {
                            throw new Error('Circuit breaker is OPEN');
                        }
                    }
                    
                    try {
                        const result = await fn();
                        this.onSuccess();
                        return result;
                    } catch (error) {
                        this.onFailure();
                        throw error;
                    }
                }
                
                onSuccess() {
                    this.failureCount = 0;
                    this.state = 'CLOSED';
                }
                
                onFailure() {
                    this.failureCount++;
                    this.lastFailureTime = Date.now();
                    
                    if (this.failureCount >= this.threshold) {
                        this.state = 'OPEN';
                    }
                }
            }
            
            let result = "Testing advanced async/await patterns:\n\n";
            
            try {
                // Test retry pattern
                result += "1. Retry pattern:\n";
                const flakyFunction = () => {
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            if (Math.random() > 0.6) {
                                resolve("Success after retry!");
                            } else {
                                reject(new Error("Random failure"));
                            }
                        }, 500);
                    });
                };
                
                const retryResult = await retryAsync(flakyFunction, 3, 500);
                result += `   Result: ${retryResult}\n\n`;
                
                // Test timeout pattern
                result += "2. Timeout pattern:\n";
                const slowFunction = () => new Promise(resolve => setTimeout(resolve, 2000));
                const fastFunction = () => new Promise(resolve => setTimeout(resolve, 500));
                
                try {
                    await withTimeout(slowFunction(), 1000);
                    result += "   Slow function timed out (expected)\n";
                } catch (error) {
                    result += `   Slow function timed out: ${error.message}\n`;
                }
                
                try {
                    const fastResult = await withTimeout(fastFunction(), 1000);
                    result += `   Fast function completed: ${fastResult}\n\n`;
                } catch (error) {
                    result += `   Fast function failed: ${error.message}\n\n`;
                }
                
                // Test circuit breaker
                result += "3. Circuit breaker pattern:\n";
                const circuitBreaker = new CircuitBreaker(2, 5000);
                
                const testFunction = () => {
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            if (Math.random() > 0.5) {
                                resolve("Success!");
                            } else {
                                reject(new Error("Service unavailable"));
                            }
                        }, 200);
                    });
                };
                
                for (let i = 0; i < 5; i++) {
                    try {
                        const result = await circuitBreaker.execute(testFunction);
                        result += `   Attempt ${i + 1}: ${result}\n`;
                    } catch (error) {
                        result += `   Attempt ${i + 1}: ${error.message}\n`;
                    }
                }
                
                result += "\nAll advanced patterns tested successfully!";
                displayResult('advanced-result', result, 'success');
            } catch (error) {
                displayResult('advanced-result', `Error testing patterns: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>

